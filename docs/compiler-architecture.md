# Stitch UI 编译器架构设计

## 概述

Stitch 不是一个简单的"JSON 转 HTML"渲染器，而是一个完整的 **UI 编译器**。

它的职责是：将 AI 产出的非结构化意图，编译为工程级可交付的 Web 资源。

```
AI 意图 (模糊、带幻觉)  →  编译器  →  工程级代码 (精确、可用)
```

---

## 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           输入层 (Input Layer)                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ session_id  │  │  context    │  │ description │  │   schema    │    │
│  │ 会话标识    │  │ 语义种子    │  │ 自然语言指令 │  │ 结构化数据  │    │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘    │
└─────────┼────────────────┼────────────────┼────────────────┼───────────┘
          │                │                │                │
          ▼                ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend Layer)                           │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    1. 词法分析器 (Lexer)                          │   │
│  │    解析 [Layout] [Theme] [Content] 等标签，生成 Token 流          │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    2. 语法分析器 (Parser)                         │   │
│  │    将 Token 流构建为抽象语法树 (AST)                              │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    3. 语义分析器 (Semantic Analyzer)              │   │
│  │    校验组件嵌套合法性、必填属性、类型匹配                          │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  │ AST
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        中端层 (Middle Layer)                             │
│                                                                          │
│  ┌─────────────────────────────────┐  ┌──────────────────────────────┐  │
│  │  4. 设计系统合成器               │  │  5. 幻觉校对器                │  │
│  │     (Design System Synthesizer) │  │     (Hallucination Checker)  │  │
│  │                                 │  │                              │  │
│  │  context + session_id           │  │  比对 AI 输出与原始输入      │  │
│  │         ↓                       │  │  检测并修正胡编内容          │  │
│  │  getOrCreateDesignSystem()      │  │  强制截断溢出文本            │  │
│  │         ↓                       │  │                              │  │
│  │  Design Tokens (CSS Variables)  │  │                              │  │
│  └────────────────┬────────────────┘  └──────────────┬───────────────┘  │
│                   │                                  │                   │
│                   └──────────────┬───────────────────┘                   │
│                                  ▼                                       │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    6. IR 生成器 (IR Generator)                    │   │
│  │    AST + Tokens → 中间表示 (Intermediate Representation)          │   │
│  │    UINode JSON 就是我们的 IR                                      │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    7. 优化器 (Optimizer)                          │   │
│  │    - 样式去重 (CSS Deduplication)                                 │   │
│  │    - 组件合并 (Component Folding)                                 │   │
│  │    - 死代码消除 (Dead Code Elimination)                           │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  │ Optimized IR
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        后端层 (Backend Layer)                            │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    8. 代码生成器 (Code Generator)                 │   │
│  │                                                                   │   │
│  │    IR → 目标代码，支持多种后端：                                   │   │
│  │                                                                   │   │
│  │    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │   │
│  │    │ React 后端  │  │ HTML 后端   │  │ HEEx 后端   │             │   │
│  │    │ (实时预览)  │  │ (静态导出)  │  │ (Phoenix)   │             │   │
│  │    └─────────────┘  └─────────────┘  └─────────────┘             │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    9. 资源打包器 (Bundler)                        │   │
│  │    - CSS 提取与压缩                                               │   │
│  │    - 图标/字体内联                                                │   │
│  │    - 临界 CSS 注入                                                │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           输出层 (Output Layer)                          │
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │  React DOM  │  │ HTML 文件   │  │  PNG/PDF    │  │  HEEx 代码  │    │
│  │  (Canvas)   │  │ (下载)      │  │  (快照)     │  │  (Phoenix)  │    │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 模块详解

### 1. 词法分析器 (Lexer)

**职责**：将 description 中的自然语言指令解析为 Token 流。

**输入**：
```
[Layout] Dashboard 布局，顶部统计卡片
[Content - Header] 标题"用户管理"，按钮"新增"
[Theme] 企业风格，主色蓝色
```

**输出**：
```
[LAYOUT_TAG, "Dashboard 布局，顶部统计卡片"]
[CONTENT_TAG, "Header", "标题"用户管理"，按钮"新增""]
[THEME_TAG, "企业风格，主色蓝色"]
```

---

### 2. 语法分析器 (Parser)

**职责**：将 Token 流构建为抽象语法树 (AST)。

**输出 AST**：
```
PageNode
├── LayoutNode (type: "dashboard")
├── ThemeNode (style: "enterprise", primary: "blue")
└── ContentNode
    ├── HeaderNode
    │   ├── TitleNode (text: "用户管理")
    │   └── ButtonNode (text: "新增")
    └── ...
```

---

### 3. 语义分析器 (Semantic Analyzer)

**职责**：校验 AST 的合法性。

**检查项**：
- 组件嵌套是否合法（Table 不能直接放在 Button 里）
- 必填属性是否存在（StatisticCard 必须有 label 和 value）
- 类型是否匹配（columns 必须是数字）
- 引用是否存在（icon="xxx" 必须是合法的图标名）

**输出**：校验通过的 AST，或错误列表。

---

### 4. 设计系统合成器 (Design System Synthesizer)

**职责**：根据 context 和 session_id 生成 Design Tokens。

**核心机制**：
```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   context = "医疗健康App，专业可信"                      │
│                 │                                       │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  1. 语义约束 (Semantic)     │                      │
│   │     "医疗" → 蓝绿色相区间   │                      │
│   │     "专业" → 低饱和度范围   │                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  2. Hash 定位 (Hashing)     │                      │
│   │     hash(context) = 0x3A7F  │                      │
│   │     hue = 150 + (hash % 50) │                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  3. 色阶生成 (Scale Gen)    │                      │
│   │     primary-50 ~ primary-950│                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  4. Session 锁定 (Lock)     │                      │
│   │     存入 SessionState       │                      │
│   │     后续页面强制继承        │                      │
│   └─────────────────────────────┘                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**输出**：Design Tokens (CSS Variables)
```css
:root {
  --primary: hsl(178, 52%, 43%);
  --primary-50: hsl(178, 52%, 95%);
  --primary-100: hsl(178, 52%, 85%);
  ...
  --radius: 8px;
  --spacing-unit: 4px;
}
```

---

### 5. 幻觉校对器 (Hallucination Checker)

**职责**：检测并修正 AI 胡编的内容。

**检查项**：
- **文本比对**：AI 生成的文案是否与用户原始输入相符
- **数值合理性**：统计数字是否在合理范围内
- **布局溢出**：文本是否会撑爆容器

**处理方式**：
- 发现胡编 → 标记警告，请求 AI 重新生成
- 发现溢出 → 强制截断，添加省略号

---

### 6. IR 生成器 (IR Generator)

**职责**：将 AST + Design Tokens 转换为中间表示 (IR)。

我们的 **UINode JSON 就是 IR**：
```json
{
  "type": "Layout",
  "props": { "direction": "column" },
  "style": { "theme": "medical", "tokens": {...} },
  "children": [...]
}
```

---

### 7. 优化器 (Optimizer)

**职责**：优化 IR，减少冗余。

**优化项**：
- **样式去重**：多个组件用同一颜色，只定义一次 CSS 变量
- **组件合并**：连续的 Text 节点合并为一个
- **死代码消除**：移除 `display: none` 的组件

---

### 8. 代码生成器 (Code Generator)

**职责**：将 IR 转换为目标代码。

**支持的后端**：

| 后端 | 用途 | 输出 |
|------|------|------|
| React | 实时预览 | React 组件树 |
| HTML | 静态导出 | HTML + CSS 文件 |
| HEEx | Phoenix 集成 | HEEx 模板代码 |
| Image | 快照导出 | PNG/PDF |

---

### 9. 资源打包器 (Bundler)

**职责**：打包最终资源。

**功能**：
- CSS 提取与压缩
- 临界 CSS 内联到 `<head>`
- 图标 SVG 内联
- 字体子集化

---

## 增量编译 (Edit Design)

当用户修改设计时，不需要全量重新编译：

```
Edit 指令: [Edit - Table] 新增一列"登录时间"
                │
                ▼
        ┌───────────────┐
        │  Diff 计算器   │  比对新旧 AST
        └───────┬───────┘
                │
                ▼
        ┌───────────────┐
        │  增量更新      │  只更新 Table 节点
        └───────┬───────┘
                │
                ▼
        ┌───────────────┐
        │  Patch 生成    │  生成最小化补丁
        └───────────────┘
```

---

## 目录结构

```
src/lib/compiler/
├── frontend/                 # 前端层
│   ├── lexer.ts             # 词法分析器
│   ├── parser.ts            # 语法分析器
│   ├── semantic.ts          # 语义分析器
│   └── ast.ts               # AST 类型定义
│
├── middle/                   # 中端层
│   ├── synthesizer.ts       # 设计系统合成器
│   ├── session.ts           # Session State 管理
│   ├── hallucination.ts     # 幻觉校对器
│   ├── ir.ts                # IR 生成器
│   └── optimizer.ts         # 优化器
│
├── backend/                  # 后端层
│   ├── codegen/
│   │   ├── react.tsx        # React 后端
│   │   ├── html.ts          # HTML 后端
│   │   └── heex.ts          # HEEx 后端
│   └── bundler.ts           # 资源打包器
│
├── themes/                   # 主题系统（已有）
│   ├── tokens.ts
│   ├── presets.ts
│   └── override.ts
│
└── index.ts                  # 编译器入口
```

---

## API 设计

```typescript
// 编译器入口
const compiler = new StitchCompiler();

// 完整编译
const result = await compiler.compile({
  sessionId: "sess_001",
  context: "医疗健康App，专业可信",
  description: "[Layout] Dashboard... [Content] ...",
  schema: {...},
});

// 增量编译
const patch = await compiler.patch({
  sessionId: "sess_001",
  screenId: "screen_001",
  edits: "[Edit - Table] 新增一列",
});

// 导出
await compiler.export(result, { format: "html" });
await compiler.export(result, { format: "png", scale: 2 });
```

---

## 与渲染器的区别

| 维度 | 渲染器 (Renderer) | 编译器 (Compiler) |
|------|------------------|------------------|
| 输入 | 结构化 JSON | 非结构化意图 + JSON |
| 分析 | 无 | 词法/语法/语义分析 |
| 优化 | 无 | 样式去重/组件合并 |
| 状态 | 无状态 | Session State |
| 校验 | 无 | 幻觉检测/内容校对 |
| 输出 | 单一格式 | 多后端支持 |
| 增量 | 全量渲染 | 增量编译 |

---

## 补充机制

### Session State 继承（第二级约束）

在设计系统合成器中，需要实现会话级状态锁定：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Session State Manager                         │
│                                                                  │
│  首次渲染:                                                        │
│    sessionStore.has(sessionId) == false                          │
│         ↓                                                        │
│    theme = matchTheme(context)                                   │
│         ↓                                                        │
│    sessionStore.set(sessionId, { theme, context, lockedAt })     │
│         ↓                                                        │
│    返回 theme（新创建）                                           │
│                                                                  │
│  后续渲染:                                                        │
│    sessionStore.has(sessionId) == true                           │
│         ↓                                                        │
│    返回 sessionStore.get(sessionId).theme（强制继承）             │
│         ↓                                                        │
│    忽略传入的 context（即使有差异）                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**作用**：即使规划层传入的 context 有微小差异（空格、大小写），也能保证同一 Session 下的所有页面使用相同主题。

---

### AST Diff 计算（增量编译）

处理 `[Edit - xxx]` 指令时，不重新编译整个页面：

```
┌─────────────────────────────────────────────────────────────────┐
│                      AST Diff Engine                             │
│                                                                  │
│  输入:                                                           │
│    - 旧 AST (从 screen_xxx.json 读取)                            │
│    - Edit 指令 ([Edit - Table] 新增一列)                          │
│                                                                  │
│  处理:                                                           │
│    1. 定位目标节点 (type == "Table")                              │
│    2. 解析修改意图 (新增列)                                       │
│    3. 生成 Patch 对象                                            │
│                                                                  │
│  输出:                                                           │
│    {                                                             │
│      "op": "add",                                                │
│      "path": "/children/2/props/columns/-",                      │
│      "value": { "key": "lastLogin", "label": "最后登录" }        │
│    }                                                             │
│                                                                  │
│  应用:                                                           │
│    applyPatch(oldAST, patch) → newAST                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 错误恢复机制

编译器遇到错误时的降级策略：

| 阶段 | 错误类型 | 处理方式 |
|------|---------|---------|
| 词法分析 | 标签不识别 | 跳过该标签，记录警告，继续解析 |
| 语法分析 | 结构不完整 | 尝试自动补全，插入空节点 |
| 语义分析 | 组件嵌套非法 | 自动调整为合法结构（如 Button 包 Table → 提升 Table） |
| 设计合成 | 主题匹配失败 | 降级到默认主题 (tech) |
| 幻觉校对 | 内容不匹配 | 标记警告，请求 AI 重新生成 |
| 代码生成 | 组件未注册 | 渲染为占位符 + 错误提示 |

---

### Platform 分支处理

在 Component Factory 层，根据 platform 执行不同的编排逻辑：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Platform Adapter                              │
│                                                                  │
│  if platform == "web":                                           │
│    - 允许 Grid 多列布局                                          │
│    - 允许侧边栏导航                                              │
│    - 屏幕比例 16:9                                               │
│                                                                  │
│  if platform == "mobile":                                        │
│    - 强制垂直 Stack 布局                                         │
│    - 注入底部 TabBar（如果 mobile_navigation 存在）              │
│    - 屏幕比例 9:16                                               │
│    - 调整间距比例（更紧凑）                                      │
│    - 字体稍大（触控友好）                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 规划层与编译器的协作

### 核心架构："单脑多手"

这是一个**"集权规划，分权渲染"**的架构：

- **规划层（AI）**：唯一的"大脑"，一次性规划所有页面，输出 DSL
- **编译器（代码）**：多个并行的"翻译机器"，确定性地把 DSL 变成页面

```
┌─────────────────────────────────────────────────────────────────┐
│  用户输入                                                        │
│  "做一个 5 页的技术分享 PPT"                                     │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI（单个大脑）                                            │
│                                                                  │
│  一次性思考，输出 5 份 JSON（每份包含一页的 DSL）：                │
│                                                                  │
│  [                                                               │
│    {                                                             │
│      "title": "封面",                                            │
│      "context": "技术分享PPT，企业风格",                          │
│      "description": "[Layout] Hero 布局\n[Content] 标题'架构'..."│
│    },                                                            │
│    {                                                             │
│      "title": "第2页",                                           │
│      "context": "技术分享PPT，企业风格",  ← 同样的 context        │
│      "description": "[Layout] 两栏布局\n[Content - Left]..."    │
│    },                                                            │
│    ... (共 5 份)                                                 │
│  ]                                                               │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  分发层（调度器）                                                 │
│                                                                  │
│  接收 5 份 JSON，分发给 5 个编译器实例并行处理                    │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  编译器层（纯代码，不是 AI）                                      │
│                                                                  │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │编译器 1 │ │编译器 2 │ │编译器 3 │ │编译器 4 │ │编译器 5 │   │
│  │ P1.json │ │ P2.json │ │ P3.json │ │ P4.json │ │ P5.json │   │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │
│       ↓           ↓           ↓           ↓           ↓         │
│    P1.html    P2.html    P3.html    P4.html    P5.html         │
│                                                                  │
│  因为不思考，所以极速并行                                        │
│  因为不思考，所以绝对忠诚（色号一致、风格统一）                   │
└─────────────────────────────────────────────────────────────────┘
```

### 为什么不用"多个 AI Agent 并行"？

| 方案 | 问题 |
|------|------|
| 5 个 AI 分头写 | 风格会打架（AI 有随机性） |
| 5 个 AI 分头写 | 成本高、速度慢 |
| 5 个 AI 分头写 | 逻辑断层（不理解整体起承转合） |
| **1 个 AI + 5 个编译器** | ✅ 风格统一、极速、确定性 |

### 数据流详解

```
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI 输出的 JSON 结构                                      │
│                                                                  │
│  {                                                               │
│    "function_call": "generate_design",                          │
│    "arguments": {                                                │
│      "title": "用户管理",                                        │
│      "context": "医疗健康App，企业风格",    ← Hash 种子          │
│      "description": "..."                   ← DSL 在这里        │
│    }                                                             │
│  }                                                               │
│                                                                  │
│  JSON 是"壳"，DSL 是"核"                                        │
│  - title/context：元信息，告诉编译器"用哪套主题"                 │
│  - description：真正的布局图纸                                   │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  description 字段里的 DSL（标签化格式）                          │
│                                                                  │
│  [Layout] Dashboard 布局，顶部统计卡片，下方数据表格              │
│  [Theme] 企业风格，主色调蓝色                                    │
│  [Content - Header] 标题"用户管理"，右侧"新增用户"按钮           │
│  [Content - Stats] 三个统计卡片：用户总数、活跃用户、新增用户     │
│  [Content - Table] 用户列表，列：用户名、邮箱、状态、操作         │
│                                                                  │
│  这是规划层 AI 输出的格式                                        │
│  标签是结构化的，内容是半自然语言                                │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  编译器内部：Zod 转换为 INTENT/ENTITY/ATTR 结构                  │
│                                                                  │
│  编译器用 Zod 把标签化 DSL 转成结构化的中间表示：                 │
│                                                                  │
│  {                                                               │
│    intent: "CREATE",                                             │
│    root: {                                                       │
│      type: "PAGE",                                               │
│      attrs: { layout: "DASHBOARD", theme: "ENTERPRISE_BLUE" },  │
│      children: [                                                 │
│        {                                                         │
│          type: "HEADER",                                         │
│          children: [                                             │
│            { type: "TITLE", attrs: { text: "用户管理" } },       │
│            { type: "BUTTON", attrs: { text: "新增用户" } }       │
│          ]                                                       │
│        },                                                        │
│        { type: "STATS", attrs: { items: [...] } },              │
│        { type: "TABLE", attrs: { columns: [...] } }             │
│      ]                                                           │
│    }                                                             │
│  }                                                               │
│                                                                  │
│  INTENT/ENTITY/ATTR 是编译器内部的中间表示                       │
│  不是 AI 输出的，是 Zod 转换出来的                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### DSL 的两层结构

| 层级 | 格式 | 谁生成 | 用途 |
|------|------|--------|------|
| **外层** | `[Layout] xxx\n[Content - Header] xxx` | 规划层 AI | 给编译器的输入 |
| **内层** | `INTENT/ENTITY/ATTR` 结构 | 编译器（Zod） | 编译器内部的 AST |

AI 输出标签化 DSL（容错性高），编译器转成结构化 AST（确定性高）。

### 逻辑综合层的"语义收敛"

编译器用 Zod 处理三种语义收敛：

```
┌─────────────────────────────────────────────────────────────────┐
│                    语义收敛 (Semantic Convergence)               │
│                                                                  │
│  输入：[Content - Header] 标题"用户管理"，右侧"新增用户"按钮     │
│                                                                  │
│  1. 解析标签 (Chevrotain)                                        │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ { type: "content", param: "Header",                 │     │
│     │   content: "标题'用户管理'，右侧'新增用户'按钮" }    │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  2. 内容解析 + 结构化 (Zod)                                      │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ {                                                   │     │
│     │   type: "HEADER",                                   │     │
│     │   children: [                                       │     │
│     │     { type: "TITLE", attrs: { text: "用户管理" } }, │     │
│     │     { type: "BUTTON", attrs: {                      │     │
│     │       text: "新增用户",                             │     │
│     │       position: "RIGHT"    ← 从"右侧"推断          │     │
│     │     }}                                              │     │
│     │   ]                                                 │     │
│     │ }                                                   │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  3. 别名映射 + 默认值补全 (Zod transform)                        │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ BUTTON 没指定 color → 默认 "primary"               │     │
│     │ BUTTON 没指定 size  → 默认 "md"                    │     │
│     │ position: "RIGHT"   → className: "ml-auto"         │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 技术选型：语义收敛

### 为什么用 Zod 而不是 NLP 库

| 对比项 | Compromise/Natural (NLP) | Zod |
|--------|--------------------------|-----|
| **设计目标** | 处理自然语言文本 | 处理结构化数据 |
| **输入** | "我要一个蓝色按钮" | `{ color: "BLUE" }` |
| **输出** | 概率性（可能识别错） | 确定性（转换规则明确） |
| **性能** | 较慢（需要分词、标注） | 快（直接查表） |
| **依赖** | 较重（词典、模型文件） | 轻量（纯 JS） |
| **类型安全** | 无 | 完美 TypeScript 支持 |

**核心原因**：规划层 AI 输出的已经是结构化 DSL，不是自然语言。

```
自然语言: "我要一个蓝色按钮"     ← 需要 NLP 理解（规划层做）
结构化:   ATTR: COLOR(BLUE)      ← 只需要 Map 查表（编译器做）
```

对于结构化输入，用 NLP 是**杀鸡用牛刀**。

---

## 视觉引擎架构

### 核心定位：视觉物理规律 (Visual Physics)

视觉引擎不只是"算几个色号"，它在为整个页面构建一套**视觉物理规律**。

**与逻辑层的关系**：样式与逻辑分离

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  第一层：逻辑综合层              第二层：视觉引擎                │
│  ────────────────────           ────────────────────            │
│  处理"是什么"和"在哪里"          处理"整体感觉"                  │
│                                                                  │
│  输入: DSL                       输入: context + hash seed      │
│  输出: AST (结构树)              输出: Design Tokens (CSS 变量)  │
│                                                                  │
│       │                               │                          │
│       └───────────┬───────────────────┘                          │
│                   ▼                                              │
│          第三层：组件工厂                                        │
│          把"皮肤"贴在"骨头"上                                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

这种并行架构的意义：
同一套逻辑树（AST），只要换一个视觉引擎的 Hash 种子，
就能瞬间从"严谨的金融后台"变成"活泼的社交 App"。
```

---

### 视觉引擎的 5 个控制维度

除了颜色，视觉引擎基于 Hash 种子动态生成一整套 Design Tokens，控制以下 5 个关键维度：

#### A. 空间尺度系统 (Spacing & Sizing Scale) — "呼吸感"

决定页面的"呼吸感"，即元素之间的空间松紧程度。

**Hash 影响**：决定基础步长（4px / 6px / 8px）和间距系数

**具体 CSS 属性**：

| 属性 | 紧凑 (0.8x) | 标准 (1.0x) | 宽松 (1.5x) |
|------|------------|------------|------------|
| `--base-unit` | 4px | 8px | 8px |
| `--spacing-xs` | 2px | 4px | 6px |
| `--spacing-sm` | 4px | 8px | 12px |
| `--spacing-md` | 8px | 16px | 24px |
| `--spacing-lg` | 12px | 24px | 36px |
| `--spacing-xl` | 16px | 32px | 48px |
| `--gap-card` | 8px | 16px | 24px |
| `--padding-card` | 12px | 16px | 24px |
| `--padding-section` | 16px | 24px | 40px |
| `--line-height-body` | 1.4 | 1.5 | 1.75 |

**场景示例**：

```
紧凑型（金融后台）                宽松型（营销页面）
┌────────────────────┐           ┌────────────────────────────┐
│┌────┐┌────┐┌────┐ │           │                            │
││统计││统计││统计│ │           │  ┌──────┐    ┌──────┐     │
│└────┘└────┘└────┘ │           │  │ 统计 │    │ 统计 │     │
│┌──────────────────┐│           │  └──────┘    └──────┘     │
││     数据表格     ││           │                            │
│└──────────────────┘│           │  ┌──────┐    ┌──────┐     │
└────────────────────┘           │  │ 统计 │    │ 统计 │     │
                                 │  └──────┘    └──────┘     │
信息密度高，适合专业用户          └────────────────────────────┘
                                 留白充足，适合浏览型场景
```

#### B. 字体排版系统 (Typography System)

**Hash 影响**：决定字阶比率（Modular Scale）

**字阶比率说明**：

| 比率 | 名称 | 适用场景 | H1 相对 body |
|------|------|---------|-------------|
| 1.125 | Major Second | 紧凑界面、数据密集 | 1.42x |
| 1.25 | Major Third | 企业应用、正文为主 | 1.95x |
| 1.333 | Perfect Fourth | 博客、文档 | 2.37x |
| 1.5 | Perfect Fifth | 营销页面 | 3.38x |
| 1.618 | Golden Ratio | 品牌展示、艺术感 | 4.24x |

**具体 CSS 属性**：

```css
/* 字阶比率 1.25 (Major Third) 示例 */
:root {
  --font-scale: 1.25;
  --font-size-xs: 0.64rem;    /* 10.24px */
  --font-size-sm: 0.8rem;     /* 12.8px */
  --font-size-base: 1rem;     /* 16px */
  --font-size-lg: 1.25rem;    /* 20px */
  --font-size-xl: 1.563rem;   /* 25px */
  --font-size-2xl: 1.953rem;  /* 31.25px */
  --font-size-3xl: 2.441rem;  /* 39px */

  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
}
```

#### C. 形状与边框规范 (Shape & Elevation)

**Hash 影响**：决定圆角弧度和阴影深度

**具体 CSS 属性**：

| 风格 | 圆角 | 阴影 | 适用场景 |
|------|------|------|---------|
| 硬朗 | 0-4px | 浓重 | 金融、法务 |
| 中性 | 6-8px | 中等 | 企业应用 |
| 柔和 | 12-16px | 轻盈 | 消费品、社交 |
| 胶囊 | 9999px | 极轻 | 儿童、创意 |

```css
/* 硬朗风格 */
:root {
  --radius-sm: 2px;
  --radius-md: 4px;
  --radius-lg: 6px;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  --shadow-md: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
}

/* 柔和风格 */
:root {
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 8px rgba(0,0,0,0.06);
  --shadow-lg: 0 8px 16px rgba(0,0,0,0.08);
}
```

#### D. 装饰性元元素 (Ornamentation)

**作用**：决定是否在背景中加入微妙的纹理，增强氛围感

**具体 CSS 属性**：

```css
:root {
  /* 点阵纹理 */
  --pattern-dots: radial-gradient(circle, rgba(0,0,0,0.03) 1px, transparent 1px);
  --pattern-dots-size: 20px 20px;

  /* 网格纹理 */
  --pattern-grid: linear-gradient(rgba(0,0,0,0.02) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px);
  --pattern-grid-size: 24px 24px;

  /* 渐变遮罩 */
  --gradient-fade: linear-gradient(180deg, transparent 0%, var(--background) 100%);

  /* 噪点纹理（通过 SVG filter 或图片） */
  --noise-opacity: 0.03;
}

/* 应用示例 */
.section-background {
  background-image: var(--pattern-dots);
  background-size: var(--pattern-dots-size);
}
```

**场景控制**：

| 场景 | 纹理类型 | 强度 |
|------|---------|------|
| 技术/金融 | 无或极淡网格 | 0-0.02 |
| 企业应用 | 淡点阵 | 0.02-0.03 |
| 创意/营销 | 渐变+噪点 | 0.03-0.05 |
| 儿童/活泼 | 彩色点阵/波纹 | 0.05-0.08 |

#### E. 语义映射转换 (Semantic Mapping)

**作用**：把抽象指令 `COLOR(BLUE)` 转换为场景特定的色值

```
┌─────────────────────────────────────────────────────────────────┐
│  COLOR(BLUE) 在不同场景的映射                                    │
│                                                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ 技术调研        │  │ 儿童教育        │  │ 医疗健康        │  │
│  │                 │  │                 │  │                 │  │
│  │  ████████████   │  │  ████████████   │  │  ████████████   │  │
│  │  #1E40AF       │  │  #60A5FA       │  │  #0891B2       │  │
│  │  深邃蓝        │  │  天空蓝        │  │  青蓝          │  │
│  │                 │  │                 │  │                 │  │
│  │  特征:         │  │  特征:         │  │  特征:         │  │
│  │  深邃、专业    │  │  活泼、明亮    │  │  清洁、可信    │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 视觉引擎的输出

最终产出的不是图片，而是一张 **CSS 变量表**：

```css
:root {
  /* A. 空间尺度 */
  --base-unit: 8px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --gap-card: 16px;
  --padding-card: 16px;
  --line-height-body: 1.5;

  /* B. 字体排版 */
  --font-scale: 1.25;
  --font-size-base: 16px;
  --font-size-lg: 20px;
  --font-size-xl: 25px;
  --font-weight-heading: 600;

  /* C. 形状边框 */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.07);

  /* D. 装饰纹理 */
  --pattern-dots: radial-gradient(...);
  --noise-opacity: 0.02;

  /* E. 语义颜色 */
  --primary-color: #1a73e8;
  --primary-50: #eff6ff;
  --primary-100: #dbeafe;
  /* ... 完整色阶 */
}
```

---

### 为什么这样设计很重要

**设计变得"可计算"**：

1. **确定性**：同一项目，无论生成几次，间距和颜色永远对齐
2. **动态性**：只需改动一个 Seed，整套 UI 的"性格"会发生翻天覆地的变化
3. **可复现**：`hash(context + session_id)` 保证同样输入 → 同样输出

如果只是写死几个 Preset，那就不叫编译器。视觉引擎让设计从"选模板"变成"算出来"。

---

## 组件工厂层 (Component Factory)

### 核心定位

组件工厂是编译器的**第三层**，负责把"骨头"（AST）和"皮肤"（Design Tokens）组装成活的 React 组件树。

```
┌─────────────────────────────────────────────────────────────────┐
│  如果把 UI 比作一辆车：                                          │
│                                                                  │
│  规划层      → 图纸                                              │
│  视觉引擎    → 调色漆和选内饰                                    │
│  工厂层      → 组装车间                                          │
│               ├─ 零件匹配：把图纸上的"轮子"对应到"米其林轮胎"    │
│               ├─ 灌浆组装：把零件焊在一起（构建 DOM 树）         │
│               ├─ 通电测试：接通电路（绑定交互事件）              │
│               └─ 最后喷漆：根据内饰方案刷漆（注入 Design Tokens）│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 输入与输出

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  输入                                                            │
│  ────                                                            │
│  1. AST (来自逻辑综合层)                                         │
│     {                                                            │
│       type: "PAGE",                                              │
│       children: [                                                │
│         { type: "HEADER", children: [...] },                    │
│         { type: "TABLE", attrs: { columns: [...] } }            │
│       ]                                                          │
│     }                                                            │
│                                                                  │
│  2. Design Tokens (来自视觉引擎)                                 │
│     {                                                            │
│       "--primary-color": "#1a73e8",                             │
│       "--spacing-md": "16px",                                   │
│       "--radius-md": "8px",                                     │
│       ...                                                        │
│     }                                                            │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  输出                                                            │
│  ────                                                            │
│  React 组件树 (可直接渲染的 ReactNode)                           │
│                                                                  │
│  <ThemeProvider tokens={designTokens}>                          │
│    <Page>                                                        │
│      <Header>                                                    │
│        <Title>用户管理</Title>                                   │
│        <Button onClick={stub}>新增用户</Button>                  │
│      </Header>                                                   │
│      <Table columns={normalizedColumns} />                      │
│    </Page>                                                       │
│  </ThemeProvider>                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 四大核心职责

#### 1. 属性转换与归一化 (Props Normalization)

规划层发出的 DSL 参数是**语义化**的，底层 React 组件需要的是**具体值**。

```
┌─────────────────────────────────────────────────────────────────┐
│  DSL 语义参数              →              React 具体值           │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  size: "large"            →    className="text-lg p-4"          │
│  size: "small"            →    className="text-sm p-2"          │
│                                                                  │
│  spacing: "compact"       →    className="p-2 gap-1"            │
│  spacing: "comfortable"   →    className="p-4 gap-3"            │
│                                                                  │
│  color: "primary"         →    style={{ color: tokens.primary }}│
│  color: "danger"          →    style={{ color: tokens.danger }} │
│                                                                  │
│  variant: "outlined"      →    className="border border-primary │
│                                           bg-transparent"       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
function transformProps(
  astProps: Record<string, any>,
  tokens: DesignTokens
): Record<string, any> {
  const result: Record<string, any> = {};

  // 尺寸转换
  if (astProps.size) {
    const sizeMap = {
      small: { className: "text-sm p-2", style: { fontSize: tokens["--font-size-sm"] } },
      medium: { className: "text-base p-3", style: { fontSize: tokens["--font-size-base"] } },
      large: { className: "text-lg p-4", style: { fontSize: tokens["--font-size-lg"] } },
    };
    Object.assign(result, sizeMap[astProps.size] || sizeMap.medium);
  }

  // 间距转换
  if (astProps.spacing) {
    const spacingMap = {
      compact: `gap-[${tokens["--spacing-sm"]}]`,
      comfortable: `gap-[${tokens["--spacing-md"]}]`,
      spacious: `gap-[${tokens["--spacing-lg"]}]`,
    };
    result.className = `${result.className || ""} ${spacingMap[astProps.spacing]}`;
  }

  // 颜色转换
  if (astProps.color) {
    result.style = {
      ...result.style,
      "--btn-color": tokens[`--${astProps.color}-color`] || tokens["--primary-color"],
    };
  }

  return result;
}
```

#### 2. 插槽分发与布局递归 (Slot Distribution & Recursion)

工厂层不是一次性把页面拍扁，而是**递归地**构建组件树，并处理**插槽分发**。

```
┌─────────────────────────────────────────────────────────────────┐
│  AST 子节点                        Card 组件插槽                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  children: [                       ┌─────────────────────┐      │
│    { type: "TITLE", ... },    ──→  │ header slot         │      │
│    { type: "TEXT", ... },     ──→  │ body slot           │      │
│    { type: "BUTTON", ... }    ──→  │ footer slot         │      │
│  ]                                 └─────────────────────┘      │
│                                                                  │
│  分发规则：                                                      │
│  - 带 TITLE/HEADING 的节点 → header                             │
│  - 带 BUTTON/ACTION 的节点 → footer                             │
│  - 其他节点 → body                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**条件渲染**：如果某个插槽没有内容，工厂层会自动决定不渲染该容器：

```typescript
function distributeSlots(children: ASTNode[]): SlotDistribution {
  const slots: SlotDistribution = {
    header: [],
    body: [],
    footer: [],
  };

  for (const child of children) {
    if (["TITLE", "HEADING", "BREADCRUMB"].includes(child.type)) {
      slots.header.push(child);
    } else if (["BUTTON", "ACTION", "LINK"].includes(child.type)) {
      slots.footer.push(child);
    } else {
      slots.body.push(child);
    }
  }

  return slots;
}

// 渲染时：条件渲染空插槽
function renderCard(slots: SlotDistribution) {
  return (
    <Card>
      {slots.header.length > 0 && (
        <CardHeader>{slots.header.map(render)}</CardHeader>
      )}
      <CardBody>{slots.body.map(render)}</CardBody>
      {slots.footer.length > 0 && (
        <CardFooter>{slots.footer.map(render)}</CardFooter>
      )}
    </Card>
  );
}
```

#### 3. 事件与交互的桩函数注入 (Event Stubbing)

为了让 UI 看起来"像真的"，工厂层需要注入交互逻辑。

```
┌─────────────────────────────────────────────────────────────────┐
│  桩函数注入                                                      │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  Button                                                          │
│  ├─ onClick: () => console.log("Button clicked")                │
│  ├─ onHover: 状态变化（高亮效果）                                │
│  └─ disabled 状态处理                                            │
│                                                                  │
│  Input                                                           │
│  ├─ onChange: (e) => setValue(e.target.value)                   │
│  ├─ onFocus: 聚焦样式                                            │
│  └─ onBlur: 失焦验证                                             │
│                                                                  │
│  Menu (左侧导航)                                                 │
│  ├─ onClick: (item) => setActiveItem(item)                      │
│  └─ 联动：右侧内容区根据 activeItem 变化                         │
│                                                                  │
│  Modal                                                           │
│  ├─ onOpen / onClose                                            │
│  └─ 背景遮罩点击关闭                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**状态同步逻辑**（组件间通信隧道）：

```typescript
// 在工厂层组装时，建立组件间的通信隧道
function createInteractionContext() {
  const [state, setState] = useState({
    activeMenuItem: null,
    modalOpen: false,
    selectedRows: [],
  });

  return {
    // 菜单 → 内容区联动
    onMenuClick: (item: string) => {
      setState(s => ({ ...s, activeMenuItem: item }));
    },
    getActiveContent: () => state.activeMenuItem,

    // Modal 控制
    openModal: () => setState(s => ({ ...s, modalOpen: true })),
    closeModal: () => setState(s => ({ ...s, modalOpen: false })),
    isModalOpen: () => state.modalOpen,

    // 表格行选择
    onRowSelect: (rows: string[]) => {
      setState(s => ({ ...s, selectedRows: rows }));
    },
    getSelectedRows: () => state.selectedRows,
  };
}
```

#### 4. 运行时上下文注入 (Context Injection)

这是保证页面风格一致的**最后一关**。

```
┌─────────────────────────────────────────────────────────────────┐
│  ThemeProvider 包裹整棵树                                        │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  <ThemeProvider value={designTokens}>     ← 顶层注入             │
│    │                                                             │
│    ├─ <Page>                                                    │
│    │   ├─ <Header>                                              │
│    │   │   └─ <Button />  ← useTheme() 获取 tokens              │
│    │   │                                                        │
│    │   └─ <Table>                                               │
│    │       └─ <Cell />    ← useTheme() 获取 tokens              │
│    │                                                            │
│    └─ 任何深层组件都能通过 useTheme() 知道自己该用什么颜色       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
// 创建 Theme Context
const ThemeContext = React.createContext<DesignTokens | null>(null);

// Provider 组件
export function ThemeProvider({
  tokens,
  children,
}: {
  tokens: DesignTokens;
  children: React.ReactNode;
}) {
  // 将 tokens 注入 CSS 变量
  const style = useMemo(() => {
    const vars: Record<string, string> = {};
    for (const [key, value] of Object.entries(tokens)) {
      vars[key] = value;
    }
    return vars as React.CSSProperties;
  }, [tokens]);

  return (
    <ThemeContext.Provider value={tokens}>
      <div style={style}>{children}</div>
    </ThemeContext.Provider>
  );
}

// Hook：任何组件都能获取 tokens
export function useTheme(): DesignTokens {
  const tokens = useContext(ThemeContext);
  if (!tokens) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return tokens;
}

// 使用示例：Button 组件自动获取主题色
function Button({ children, variant = "primary" }) {
  const tokens = useTheme();

  return (
    <button
      style={{
        backgroundColor: tokens[`--${variant}-color`],
        borderRadius: tokens["--radius-md"],
        padding: `${tokens["--spacing-sm"]} ${tokens["--spacing-md"]}`,
      }}
    >
      {children}
    </button>
  );
}
```

### 完整的工厂函数

把四个职责整合在一起：

```typescript
/**
 * 组件工厂：把 AST + Design Tokens 组装成 React 组件树
 */
function ComponentFactory(
  astNode: ASTNode,
  tokens: DesignTokens,
  interactionCtx: InteractionContext
): React.ReactNode {
  // 1. 找到对应的 React 组件
  const Component = ComponentRegistry.get(astNode.type);

  if (!Component) {
    console.warn(`Unknown component: ${astNode.type}`);
    return null;
  }

  // 2. 属性转换（DSL Props → React Props）
  const normalizedProps = transformProps(astNode.attrs, tokens);

  // 3. 注入事件桩函数
  const propsWithEvents = injectEventStubs(
    normalizedProps,
    astNode.type,
    interactionCtx
  );

  // 4. 处理插槽分发（如果组件支持插槽）
  let children: React.ReactNode = null;
  if (astNode.children && astNode.children.length > 0) {
    if (Component.slots) {
      // 有插槽的组件：分发子节点到不同插槽
      const slots = distributeSlots(astNode.children, Component.slots);
      children = renderSlots(slots, tokens, interactionCtx);
    } else {
      // 普通组件：递归渲染子节点
      children = astNode.children.map((child, index) => (
        <React.Fragment key={index}>
          {ComponentFactory(child, tokens, interactionCtx)}
        </React.Fragment>
      ));
    }
  }

  // 5. 返回组装好的 React 实例
  return <Component {...propsWithEvents}>{children}</Component>;
}

/**
 * 顶层入口：包裹 ThemeProvider
 */
export function renderPage(
  ast: ASTNode,
  tokens: DesignTokens
): React.ReactNode {
  const interactionCtx = createInteractionContext();

  return (
    <ThemeProvider tokens={tokens}>
      <InteractionProvider value={interactionCtx}>
        {ComponentFactory(ast, tokens, interactionCtx)}
      </InteractionProvider>
    </ThemeProvider>
  );
}
```

### 组件注册表 (Component Registry)

工厂层需要一个**组件映射表**，把 AST 节点类型映射到真实的 React 组件：

```typescript
const ComponentRegistry = new Map<string, React.ComponentType<any>>([
  // 布局组件
  ["PAGE", Page],
  ["SECTION", Section],
  ["CARD", Card],
  ["GRID", Grid],
  ["STACK", Stack],

  // 内容组件
  ["HEADER", Header],
  ["TITLE", Title],
  ["TEXT", Text],
  ["IMAGE", Image],

  // 交互组件
  ["BUTTON", Button],
  ["INPUT", Input],
  ["SELECT", Select],
  ["CHECKBOX", Checkbox],

  // 数据展示
  ["TABLE", Table],
  ["LIST", List],
  ["STATS", StatsCard],
  ["CHART", Chart],

  // 导航组件
  ["MENU", Menu],
  ["TABS", Tabs],
  ["BREADCRUMB", Breadcrumb],

  // 反馈组件
  ["MODAL", Modal],
  ["TOAST", Toast],
  ["ALERT", Alert],
]);
```

---

## 视觉引擎版本规划

### V1：静态别名映射（当前实现）

简单的查表映射，快速可用：

```typescript
import { z } from "zod";

// ============================================
// V1: 静态别名映射
// ============================================

const colorAliases: Record<string, string> = {
  // 蓝色系
  "blue": "blue-600",
  "ocean_blue": "blue-600",
  "sky": "blue-400",
  "navy": "blue-800",
  // 绿色系
  "green": "green-600",
  "teal": "teal-600",
  "medical": "teal-600",
  // 红色系
  "red": "red-600",
  "danger": "red-600",
  "error": "red-600",
};

const ColorAttr = z.string().transform((val) => {
  const key = val.toLowerCase();
  return colorAliases[key] || key;
});

// V1 使用示例
const input = { color: "OCEAN_BLUE" };
const result = ColorAttr.parse(input.color);  // → "blue-600"
```

**V1 特点**：
- ✅ 简单、快速、可预测
- ✅ 易于调试和维护
- ❌ 不够灵活，只有有限的预设组合
- ❌ 不支持场景感知

---

### V2：场景感知 + 可计算设计（目标架构）

设计变得"可计算"，同一语义在不同场景产出不同视觉：

```
┌─────────────────────────────────────────────────────────────────┐
│                      V2 视觉引擎输入                             │
│                                                                  │
│  1. 语义属性: COLOR(BLUE), SIZE(LARGE)                          │
│  2. 场景上下文: CONTEXT("技术调研") / CONTEXT("儿童教育")        │
│  3. Hash 种子: hash(session_id + context)                       │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                   场景感知的颜色映射                             │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("技术调研")                       │   │
│  │    场景特征: 深邃、专业、可信                             │   │
│  │    色相区间: [210, 240]                                  │   │
│  │    饱和度: 60-80%                                        │   │
│  │    明度: 25-40%                                          │   │
│  │    → #1E40AF (深邃蓝)                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("儿童教育")                       │   │
│  │    场景特征: 活泼、明亮、友好                             │   │
│  │    色相区间: [200, 220]                                  │   │
│  │    饱和度: 70-90%                                        │   │
│  │    明度: 55-70%                                          │   │
│  │    → #60A5FA (天空蓝)                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("医疗健康")                       │   │
│  │    场景特征: 可信、清洁、专业                             │   │
│  │    色相区间: [180, 200]                                  │   │
│  │    饱和度: 50-70%                                        │   │
│  │    明度: 40-55%                                          │   │
│  │    → #0891B2 (青蓝)                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**V2 核心算法**：

```typescript
// ============================================
// V2: 场景感知 + Hash 确定性
// ============================================

interface ContextConstraints {
  hueRange: [number, number];
  satRange: [number, number];
  lightRange: [number, number];
  radiusScale: number;      // 圆角系数
  spacingScale: number;     // 间距系数
  fontScale: number;        // 字体系数
  shadowIntensity: number;  // 阴影强度
}

// 场景 → 约束范围
const contextConstraints: Record<string, ContextConstraints> = {
  "技术调研": {
    hueRange: [210, 240],
    satRange: [60, 80],
    lightRange: [25, 40],
    radiusScale: 0.5,       // 较小圆角，硬朗
    spacingScale: 1.0,      // 标准间距
    fontScale: 1.0,         // 标准字体
    shadowIntensity: 0.3,   // 轻阴影
  },
  "儿童教育": {
    hueRange: [200, 220],
    satRange: [70, 90],
    lightRange: [55, 70],
    radiusScale: 1.5,       // 大圆角，柔和
    spacingScale: 1.2,      // 宽松间距
    fontScale: 1.1,         // 稍大字体
    shadowIntensity: 0.5,   // 明显阴影
  },
  "医疗健康": {
    hueRange: [180, 200],
    satRange: [50, 70],
    lightRange: [40, 55],
    radiusScale: 0.75,      // 中等圆角
    spacingScale: 1.1,      // 舒适间距
    fontScale: 1.0,         // 标准字体
    shadowIntensity: 0.2,   // 极轻阴影，干净
  },
  "金融商务": {
    hueRange: [220, 250],
    satRange: [40, 60],
    lightRange: [20, 35],
    radiusScale: 0.25,      // 极小圆角，严肃
    spacingScale: 0.9,      // 紧凑间距
    fontScale: 0.95,        // 稍小字体
    shadowIntensity: 0.4,   // 中等阴影
  },
};

// Hash 函数（确定性）
function hashCode(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

// V2 颜色计算
function computeColor(
  semanticColor: string,
  context: string,
  sessionId: string
): string {
  const constraints = contextConstraints[context] || contextConstraints["技术调研"];
  const seed = hashCode(sessionId + context + semanticColor);

  const [hueMin, hueMax] = constraints.hueRange;
  const [satMin, satMax] = constraints.satRange;
  const [lightMin, lightMax] = constraints.lightRange;

  const hue = hueMin + (seed % (hueMax - hueMin));
  const sat = satMin + ((seed >> 8) % (satMax - satMin));
  const light = lightMin + ((seed >> 16) % (lightMax - lightMin));

  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

// V2 完整 Design Tokens 生成
function generateDesignTokens(
  context: string,
  sessionId: string
): Record<string, string> {
  const constraints = contextConstraints[context] || contextConstraints["技术调研"];
  const baseUnit = 8;

  return {
    // 颜色
    "--primary-color": computeColor("PRIMARY", context, sessionId),
    "--secondary-color": computeColor("SECONDARY", context, sessionId),
    "--background": computeColor("BACKGROUND", context, sessionId),
    "--foreground": computeColor("FOREGROUND", context, sessionId),

    // 空间（受场景影响）
    "--base-unit": `${baseUnit}px`,
    "--spacing-sm": `${baseUnit * constraints.spacingScale}px`,
    "--spacing-md": `${baseUnit * 2 * constraints.spacingScale}px`,
    "--spacing-lg": `${baseUnit * 3 * constraints.spacingScale}px`,

    // 圆角（受场景影响）
    "--radius-sm": `${4 * constraints.radiusScale}px`,
    "--radius-md": `${8 * constraints.radiusScale}px`,
    "--radius-lg": `${12 * constraints.radiusScale}px`,

    // 字体（受场景影响）
    "--font-scale": `${constraints.fontScale}`,
    "--font-size-base": `${16 * constraints.fontScale}px`,

    // 阴影（受场景影响）
    "--shadow-sm": `0 1px 2px rgba(0,0,0,${constraints.shadowIntensity * 0.5})`,
    "--shadow-md": `0 4px 6px rgba(0,0,0,${constraints.shadowIntensity})`,
    "--shadow-lg": `0 10px 15px rgba(0,0,0,${constraints.shadowIntensity * 1.5})`,
  };
}

// 使用示例
const tokens = generateDesignTokens("儿童教育", "sess_001");
// {
//   "--primary-color": "hsl(208, 78%, 62%)",  // 天空蓝
//   "--base-unit": "8px",
//   "--spacing-md": "19.2px",                  // 1.2x 宽松
//   "--radius-md": "12px",                     // 1.5x 大圆角
//   "--font-size-base": "17.6px",              // 1.1x 稍大
//   "--shadow-md": "0 4px 6px rgba(0,0,0,0.5)" // 明显阴影
// }
```

**V2 确定性保证**：

```
┌─────────────────────────────────────────────────────────────────┐
│                      Hash 确定性                                 │
│                                                                  │
│  输入相同 → 输出相同                                             │
│                                                                  │
│  第一次生成:                                                     │
│    generateDesignTokens("儿童教育", "sess_001")                  │
│    → "--primary-color": "hsl(208, 78%, 62%)"                    │
│                                                                  │
│  第二次生成（同样输入）:                                         │
│    generateDesignTokens("儿童教育", "sess_001")                  │
│    → "--primary-color": "hsl(208, 78%, 62%)"  ✓ 相同            │
│                                                                  │
│  不同 Session:                                                   │
│    generateDesignTokens("儿童教育", "sess_002")                  │
│    → "--primary-color": "hsl(212, 82%, 65%)"  ✗ 不同            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### V1 → V2 升级路径

```
┌─────────────────────────────────────────────────────────────────┐
│                       升级路径                                   │
│                                                                  │
│  V1 (当前)                      V2 (目标)                       │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  静态别名映射                   场景感知映射                     │
│  colorAliases["blue"]          computeColor("BLUE", context)    │
│       ↓                              ↓                          │
│  "blue-600"                    "hsl(208, 78%, 62%)"             │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  固定 Preset                    可计算设计                       │
│  presets.tech                   generateDesignTokens(context)   │
│  presets.medical                     +                          │
│  presets.edu                    Hash 确定性种子                  │
│  (12种)                         (无限组合)                       │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  渲染器 (Renderer)              编译器 (Compiler)                │
│  JSON → React                   DSL → AST → IR → 多后端         │
│  无状态                         Session State                    │
│  无校验                         幻觉检测 + 语义校验              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 拼写纠错（V1/V2 通用）

如果 AI 输出有拼写错误，用 Levenshtein 距离做模糊匹配：

```typescript
import { distance } from "fastest-levenshtein";

function fuzzyMatch(input: string, candidates: string[]): string | null {
  const threshold = 2;
  for (const candidate of candidates) {
    if (distance(input.toLowerCase(), candidate) <= threshold) {
      return candidate;
    }
  }
  return null;
}

// 使用
fuzzyMatch("BLUEE", ["blue", "red", "green"]);  // → "blue"
```

---

## 存储策略

### 核心原则

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ✅ 持久化：DSL（源代码）                                        │
│  ❌ 不持久化：AST（内存中的编译产物）                            │
│  ❌ 不持久化：Design Tokens（实时计算）                          │
│                                                                  │
│  "以计算代替存储"                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 数据流与生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  DSL (持久化 - 文件系统)                                         │
│  screens/home.dsl.json  ←───────────────────┐                   │
│       │                                      │                   │
│       ▼ 编译 (每次打开/修改时)               │ 保存修改          │
│                                              │                   │
│  AST (内存 - 不持久化)                       │                   │
│  只在编译器进程内存中存在                    │                   │
│       │                                      │                   │
│       │                                      │                   │
│       ├──────────────────────────────────────┤                   │
│       │                                      │                   │
│       ▼                                      │                   │
│  Design Tokens (内存 - 实时计算)             │                   │
│  hash(context + session_id) → CSS 变量       │                   │
│       │                                      │                   │
│       ▼                                      │                   │
│  渲染输出 (React/HTML)                       │                   │
│       │                                      │                   │
│       │  用户修改                            │                   │
│       └──────────────────────────────────────┘                   │
│          修改回写到 DSL，重新编译                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 为什么 AST 不持久化

| 方案 | 优点 | 缺点 |
|------|------|------|
| ❌ DSL + AST 都存 | 修改时可直接操作 AST | 需要保持两者同步，容易不一致 |
| ✅ 只存 DSL | 单一数据源，无同步问题 | 每次修改要先编译（但编译很快） |

**选择只存 DSL 的原因**：
1. **单一数据源**：DSL 是唯一的 truth，不会出现 AST 和 DSL 不一致的问题
2. **编译成本低**：Chevrotain + Zod 解析一个页面是毫秒级的
3. **修改更安全**：所有修改都回到 DSL 层面，经过完整的编译校验流程

### 为什么 Design Tokens 不持久化

设计是迭代的。用户今天觉得蓝色好，明天可能想试试绿色。

**实时计算的好处**：
- 用户改 context，Tokens 自动变
- 用户改参数，Tokens 自动变
- 只要输入一样，输出就一样（Hash 确定性）
- 导出时才固化，之前随便调

**"以计算代替存储"**：
- 不存整张 Token 表
- 只存 context 字符串
- 视觉引擎每次运行 `hash(context)` 都能得到一模一样的 Token 表
- 既节省空间又保证绝对一致性

### 什么要存，什么不存

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ✅ 要持久化：DSL 源文件                                         │
│                                                                  │
│     DSL 是用户意图的"源代码"。                                   │
│     用户要改文字、改布局，都是在 DSL 层面修改，                   │
│     改完重新编译。                                               │
│                                                                  │
│     存储位置：                                                   │
│     project/screens/                                             │
│     ├── home.dsl.json                                           │
│     ├── user-list.dsl.json                                      │
│     └── ...                                                      │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ✅ 要持久化：Context 配置                                       │
│                                                                  │
│     存储位置：                                                   │
│     - 项目配置文件: stitch.config.json (context, session_id)    │
│     - 会话缓存: 在规划层 AI 的对话历史里                         │
│                                                                  │
│     Context 是连接用户和 AI 的纽带，也是 Design Tokens 的种子    │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ❌ 不持久化：AST                                                │
│                                                                  │
│     AST 只在内存中存在。                                         │
│     打开页面时：DSL → 编译 → AST（内存）                         │
│     修改页面时：修改 DSL → 重新编译 → 新 AST（内存）             │
│                                                                  │
│     不直接操作 AST，所有修改都回到 DSL 层面。                    │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ❌ 不持久化：Design Tokens                                      │
│                                                                  │
│     渲染时：根据 context + session_id 实时计算                   │
│     只在导出时才固化成 CSS 文件                                  │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ✅ 导出时才生成：最终产物                                       │
│                                                                  │
│     用户点击"导出"的那一刻：                                     │
│     1. 根据当前 context + session_id 计算 Design Tokens          │
│     2. 编译所有 DSL → AST → IR → 目标代码                       │
│     3. 把 Tokens 写入 design-tokens.css（此时才固化）            │
│     4. 打包输出                                                  │
│                                                                  │
│     输出位置：                                                   │
│     dist/                                                        │
│     ├── design-tokens.css   ← 导出时生成                        │
│     ├── index.html                                               │
│     └── ...                                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 完整工作流程

#### 打开页面

```
用户打开 home 页面
       │
       ▼
读取 DSL: screens/home.dsl.json
       │
       ▼
编译: DSL → AST (进入内存)
       │
       ▼
读取 context: stitch.config.json
       │
       ▼
计算 Design Tokens: hash(context + session_id)
       │
       ▼
渲染: AST + Tokens → React 组件树
       │
       ▼
显示预览
```

#### 修改页面

用户要改按钮文字"提交"→"确认"：

```
用户点击按钮，输入新文字"确认"
       │
       ▼
定位 DSL 中对应节点
       │
       ▼
修改 DSL: [Content - Header] ... "确认"按钮
       │
       ▼
保存 DSL 文件: screens/home.dsl.json
       │
       ▼
重新编译: DSL → 新 AST (内存中替换)
       │
       ▼
Design Tokens 不变 (context 没变)
       │
       ▼
重新渲染预览
```

**注意**：不直接操作内存中的 AST，修改都回到 DSL 层面，经过完整编译流程。

#### 导出项目

```
用户点击"导出"
       │
       ▼
读取 stitch.config.json (context, session_id)
       │
       ▼
计算 Design Tokens (此时固化值)
       │
       ▼
遍历 screens/*.dsl.json
       │
       ├─→ 编译 home.dsl.json → home.html
       ├─→ 编译 user-list.dsl.json → user-list.html
       └─→ ...
       │
       ▼
写入 dist/design-tokens.css (固化的 CSS 变量)
       │
       ▼
打包输出 dist/
```

---

## 云端存储架构

### 为什么用文件系统而不是数据库

Stitch 是云端版本，但 DSL 存在服务器文件系统，不用数据库。原因：

**简单可靠**
- 不需要维护数据库
- 文件系统天然支持目录隔离
- 每个用户/项目一个目录，互不干扰

**可以用 Git 版本控制**
- 服务器上可以给每个项目初始化 Git 仓库
- 自动记录修改历史
- 用户可以回滚到任意版本

**容易备份和迁移**
- 直接打包目录就能备份
- 可以用对象存储（S3、OSS）做异地同步
- 迁移服务器只需要复制文件夹

**符合编译器的工作方式**
- 编译器读写文件是最自然的
- 不需要序列化/反序列化到数据库
- 文件路径就是资源定位符

### 服务器目录结构

```
/data/stitch/
│
├── users/
│   └── {user_id}/
│       └── projects/
│           │
│           ├── {project_id}/                    # 项目 A
│           │   ├── stitch.config.json           # 项目配置
│           │   │   {
│           │   │     "name": "医疗健康App",
│           │   │     "context": "医疗健康，专业可信",
│           │   │     "sessionId": "sess_001",
│           │   │     "createdAt": "2024-01-15",
│           │   │     "platform": "web"
│           │   │   }
│           │   │
│           │   ├── screens/                     # DSL 源文件
│           │   │   ├── home.dsl.json           # 首页
│           │   │   ├── user-list.dsl.json      # 用户列表
│           │   │   ├── user-detail.dsl.json    # 用户详情
│           │   │   └── settings.dsl.json       # 设置页
│           │   │
│           │   ├── assets/                      # 静态资源
│           │   │   ├── logo.svg
│           │   │   └── ...
│           │   │
│           │   ├── .git/                        # Git 版本控制（可选）
│           │   │
│           │   └── dist/                        # 编译输出
│           │       ├── design-tokens.css
│           │       ├── index.html
│           │       └── ...
│           │
│           └── {project_id}/                    # 项目 B
│               └── ...
│
└── tmp/                                         # 临时文件（编译中间产物）
    └── ...
```

### 文件说明

| 文件/目录 | 作用 | 持久化 |
|----------|------|--------|
| `stitch.config.json` | 项目配置（context、session_id） | ✅ |
| `screens/*.dsl.json` | DSL 源文件，用户意图的源代码 | ✅ |
| `assets/` | 用户上传的图片、图标等 | ✅ |
| `.git/` | 版本历史（可选） | ✅ |
| `dist/` | 编译输出，导出时生成 | 可选（可重新生成） |
| `tmp/` | 编译临时文件 | ❌ 用完即删 |

### 读写流程

**用户打开项目**：
1. 根据 user_id 和 project_id 定位目录
2. 读取 `stitch.config.json` 获取配置
3. 列出 `screens/` 目录下所有 DSL 文件
4. 根据 context 实时计算 Design Tokens
5. 编译 DSL → 渲染预览

**用户修改页面**：
1. 修改内存中的 DSL 结构
2. 保存到 `screens/xxx.dsl.json`
3. 重新编译该页面
4. 更新预览

**用户导出项目**：
1. 读取当前配置，计算 Design Tokens
2. 编译所有 DSL 文件
3. 生成 `dist/` 目录下的文件
4. 打包下载或部署

---

## DSL 解析与 AST 构建

### 编译器处理流程

```
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI 输出的 JSON                                           │
│  {                                                               │
│    "title": "用户管理",                                          │
│    "context": "企业后台",                                         │
│    "description": "[Layout] Dashboard...\n[Content - Header]..." │
│  }                                                               │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 1: Chevrotain 解析标签                                     │
│                                                                  │
│  输入："[Layout] Dashboard 布局\n[Content - Header] 标题..."    │
│  输出：                                                          │
│  [                                                               │
│    { type: "layout", content: "Dashboard 布局..." },            │
│    { type: "content", param: "Header", content: "标题..." },    │
│    { type: "content", param: "Stats", content: "..." },         │
│  ]                                                               │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 2: Zod 内容解析 + 结构化                                   │
│                                                                  │
│  把每个标签的 content 转成 ENTITY/ATTR 结构：                    │
│                                                                  │
│  "标题'用户管理'，右侧'新增用户'按钮"                            │
│       ↓ Zod 解析                                                 │
│  {                                                               │
│    type: "HEADER",                                               │
│    children: [                                                   │
│      { type: "TITLE", attrs: { text: "用户管理" } },            │
│      { type: "BUTTON", attrs: { text: "新增用户", pos: "RIGHT" }}│
│    ]                                                             │
│  }                                                               │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 3: 组装完整 AST                                            │
│                                                                  │
│  {                                                               │
│    intent: "CREATE",                                             │
│    root: {                                                       │
│      type: "PAGE",                                               │
│      attrs: { layout: "DASHBOARD" },                            │
│      children: [                                                 │
│        { type: "HEADER", children: [...] },                     │
│        { type: "STATS", children: [...] },                      │
│        { type: "TABLE", children: [...] }                       │
│      ]                                                           │
│    }                                                             │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### Step 1: Chevrotain 解析标签

解析 AI 输出的标签化 DSL：

```typescript
// ============================================
// lexer.ts - 解析 [Layout] [Content - xxx] 等标签
// ============================================

import { createToken, Lexer } from "chevrotain";

export const LayoutTag = createToken({
  name: "LayoutTag",
  pattern: /\[Layout\]/
});

export const ThemeTag = createToken({
  name: "ThemeTag",
  pattern: /\[Theme\]/
});

export const ContentTag = createToken({
  name: "ContentTag",
  pattern: /\[Content\s*-\s*([^\]]+)\]/
});

export const EditTag = createToken({
  name: "EditTag",
  pattern: /\[Edit\s*-\s*([^\]]+)\]/
});

export const DetailsTag = createToken({
  name: "DetailsTag",
  pattern: /\[Details\]/
});

export const TextContent = createToken({
  name: "TextContent",
  pattern: /[^\[]+/,
});

export const allTokens = [
  LayoutTag, ThemeTag, ContentTag, EditTag, DetailsTag, TextContent,
];

export const StitchLexer = new Lexer(allTokens);
```

### Step 2: Zod 内容解析

把标签内容（半自然语言）转成结构化的 ENTITY/ATTR：

```typescript
// ============================================
// content-parser.ts - Zod 解析标签内容
// ============================================

import { z } from "zod";

// 内容解析规则
const contentPatterns = {
  // 标题模式：标题"xxx" 或 标题'xxx'
  title: /标题[\"']([^\"']+)[\"']/,

  // 按钮模式：xxx按钮 或 "xxx"按钮
  button: /[\"']([^\"']+)[\"']按钮|(\S+)按钮/,

  // 位置模式：右侧、左侧、顶部、底部
  position: /(右侧|左侧|顶部|底部)/,

  // 图标模式：图标xxx 或 icon:xxx
  icon: /图标[:\s]*(\S+)|icon[:\s]*(\S+)/i,
};

// Header 内容解析器
const HeaderContentSchema = z.string().transform((content) => {
  const result: any = { type: "HEADER", children: [] };

  // 提取标题
  const titleMatch = content.match(contentPatterns.title);
  if (titleMatch) {
    result.children.push({
      type: "TITLE",
      attrs: { text: titleMatch[1] }
    });
  }

  // 提取按钮
  const buttonMatch = content.match(contentPatterns.button);
  if (buttonMatch) {
    const buttonText = buttonMatch[1] || buttonMatch[2];
    const posMatch = content.match(contentPatterns.position);

    result.children.push({
      type: "BUTTON",
      attrs: {
        text: buttonText,
        position: posMatch ? posMatch[1] : "RIGHT"
      }
    });
  }

  return result;
});

// Stats 内容解析器
const StatsContentSchema = z.string().transform((content) => {
  // 提取统计项：三个统计卡片：用户总数、活跃用户、新增用户
  const itemsMatch = content.match(/[:：](.+)/);
  if (itemsMatch) {
    const items = itemsMatch[1].split(/[,，、]/).map(s => s.trim());
    return {
      type: "STATS",
      attrs: { items }
    };
  }
  return { type: "STATS", attrs: { items: [] } };
});

// Table 内容解析器
const TableContentSchema = z.string().transform((content) => {
  // 提取列：列：用户名、邮箱、状态
  const columnsMatch = content.match(/列[:：](.+)/);
  if (columnsMatch) {
    const columns = columnsMatch[1].split(/[,，、]/).map(s => s.trim());
    return {
      type: "TABLE",
      attrs: { columns }
    };
  }
  return { type: "TABLE", attrs: { columns: [] } };
});

// 根据标签类型选择解析器
export function parseContent(tagType: string, param: string | null, content: string) {
  switch (param?.toUpperCase()) {
    case "HEADER":
      return HeaderContentSchema.parse(content);
    case "STATS":
      return StatsContentSchema.parse(content);
    case "TABLE":
      return TableContentSchema.parse(content);
    default:
      return { type: param || "UNKNOWN", attrs: { raw: content } };
  }
}
```

### Step 3: 组装 AST

```typescript
// ============================================
// ast-builder.ts - 组装完整 AST
// ============================================

import { StitchLexer } from "./lexer";
import { parseContent } from "./content-parser";

export interface ASTNode {
  type: string;
  attrs: Record<string, any>;
  children: ASTNode[];
}

export interface StitchAST {
  intent: "CREATE" | "EDIT";
  root: ASTNode;
}

export function compile(input: {
  title: string;
  context: string;
  description: string;
}): StitchAST {
  // 1. 解析标签
  const lexResult = StitchLexer.tokenize(input.description);

  // 2. 提取指令列表
  const instructions = extractInstructions(lexResult.tokens);

  // 3. 构建 AST
  const root: ASTNode = {
    type: "PAGE",
    attrs: {
      title: input.title,
      context: input.context,
      layout: "DEFAULT"
    },
    children: []
  };

  for (const inst of instructions) {
    if (inst.type === "layout") {
      // 解析布局
      root.attrs.layout = parseLayout(inst.content);
    } else if (inst.type === "content") {
      // 解析内容块
      const node = parseContent(inst.type, inst.param, inst.content);
      root.children.push(node);
    }
  }

  return {
    intent: "CREATE",
    root
  };
}

function parseLayout(content: string): string {
  if (content.includes("Dashboard")) return "DASHBOARD";
  if (content.includes("三栏") || content.includes("三列")) return "THREE_COLUMN";
  if (content.includes("两栏") || content.includes("分栏")) return "TWO_COLUMN";
  return "DEFAULT";
}
```

### 完整编译流程示例

```typescript
// 输入：规划层 AI 的 JSON
const input = {
  title: "用户管理",
  context: "企业后台，专业风格",
  description: `
[Layout] Dashboard 布局，顶部统计卡片，下方数据表格
[Theme] 企业风格，主色调蓝色
[Content - Header] 标题"用户管理"，右侧"新增用户"按钮
[Content - Stats] 三个统计卡片：用户总数、活跃用户、新增用户
[Content - Table] 用户列表，列：用户名、邮箱、状态、操作
`
};

// 编译
const ast = compile(input);

// 输出：结构化 AST
console.log(JSON.stringify(ast, null, 2));
// {
//   "intent": "CREATE",
//   "root": {
//     "type": "PAGE",
//     "attrs": {
//       "title": "用户管理",
//       "context": "企业后台，专业风格",
//       "layout": "DASHBOARD"
//     },
//     "children": [
//       {
//         "type": "HEADER",
//         "children": [
//           { "type": "TITLE", "attrs": { "text": "用户管理" } },
//           { "type": "BUTTON", "attrs": { "text": "新增用户", "position": "RIGHT" } }
//         ]
//       },
//       {
//         "type": "STATS",
//         "attrs": { "items": ["用户总数", "活跃用户", "新增用户"] }
//       },
//       {
//         "type": "TABLE",
//         "attrs": { "columns": ["用户名", "邮箱", "状态", "操作"] }
//       }
//     ]
//   }
// }
```

---

## 技术选型：AST 解析

### 为什么不用 Tree-sitter

Tree-sitter 是为**编程语言**设计的解析器生成器（TypeScript、Python、Go 等），具有以下特点：

- 处理复杂的上下文无关文法
- 支持增量解析
- 需要编写 grammar.js 语法定义
- 运行时依赖 WASM/Native 模块

**Stitch 不需要 Tree-sitter**，因为：

1. 我们的语法很简单：`INTENT`、`ENTITY`、`ATTR`
2. 不是传统编程语言，而是结构化的 DSL
3. Tree-sitter 引入的复杂度和依赖不值得

---

### 推荐方案：Chevrotain

**Chevrotain** 是 TypeScript 生态中最适合 Stitch 的选择：

| 特性 | 说明 |
|------|------|
| TypeScript 原生 | 用 TS 编写，类型支持完美 |
| 无代码生成 | 直接在运行时定义语法，无需构建步骤 |
| 高性能 | 比 PEG.js 快 3-10 倍 |
| 错误恢复 | 内置错误恢复机制，适合容错编译 |
| 零运行时依赖 | 纯 JS，不依赖 WASM 或 Native |

**安装**：
```bash
npm install chevrotain
```

---

### 备选方案对比

| 方案 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **Chevrotain** ⭐ | 结构化 DSL | TS 原生、快、错误恢复好 | 学习曲线稍陡 |
| **Peggy (PEG.js)** | 简单语法 | 语法直观、易上手 | 需代码生成步骤 |
| **Nearley + Moo** | 歧义语法 | 处理歧义能力强 | 两个库配合使用 |
| **手写正则** | 极简场景 | 零依赖 | 难扩展、难维护 |
| **Tree-sitter** | 编程语言 | 增量解析强 | 过度工程、依赖重 |

---

### Chevrotain 实现示例

#### 1. Token 定义 (lexer.ts)

```typescript
import { createToken, Lexer } from "chevrotain";

// 标签 Token
export const LayoutTag = createToken({
  name: "LayoutTag",
  pattern: /\[Layout\]/
});

export const ThemeTag = createToken({
  name: "ThemeTag",
  pattern: /\[Theme\]/
});

export const ContentTag = createToken({
  name: "ContentTag",
  pattern: /\[Content\s*-\s*([^\]]+)\]/
});

export const EditTag = createToken({
  name: "EditTag",
  pattern: /\[Edit\s*-\s*([^\]]+)\]/
});

export const DetailsTag = createToken({
  name: "DetailsTag",
  pattern: /\[Details\]/
});

// 文本内容（直到下一个标签或结束）
export const TextContent = createToken({
  name: "TextContent",
  pattern: /[^\[]+/,
});

// 换行
export const Newline = createToken({
  name: "Newline",
  pattern: /\r?\n/,
  group: Lexer.SKIPPED,
});

// 空白
export const WhiteSpace = createToken({
  name: "WhiteSpace",
  pattern: /[ \t]+/,
  group: Lexer.SKIPPED,
});

// Token 列表（顺序重要，优先匹配具体的）
export const allTokens = [
  WhiteSpace,
  Newline,
  LayoutTag,
  ThemeTag,
  ContentTag,
  EditTag,
  DetailsTag,
  TextContent,
];

export const StitchLexer = new Lexer(allTokens);
```

#### 2. Parser 定义 (parser.ts)

```typescript
import { CstParser } from "chevrotain";
import { allTokens, LayoutTag, ThemeTag, ContentTag, TextContent } from "./lexer";

class StitchParser extends CstParser {
  constructor() {
    super(allTokens, { recoveryEnabled: true });
    this.performSelfAnalysis();
  }

  // 顶层规则：指令列表
  public instructions = this.RULE("instructions", () => {
    this.MANY(() => {
      this.SUBRULE(this.instruction);
    });
  });

  // 单条指令
  private instruction = this.RULE("instruction", () => {
    this.OR([
      { ALT: () => this.SUBRULE(this.layoutInstruction) },
      { ALT: () => this.SUBRULE(this.themeInstruction) },
      { ALT: () => this.SUBRULE(this.contentInstruction) },
    ]);
  });

  // Layout 指令
  private layoutInstruction = this.RULE("layoutInstruction", () => {
    this.CONSUME(LayoutTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });

  // Theme 指令
  private themeInstruction = this.RULE("themeInstruction", () => {
    this.CONSUME(ThemeTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });

  // Content 指令
  private contentInstruction = this.RULE("contentInstruction", () => {
    this.CONSUME(ContentTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });
}

export const parser = new StitchParser();
```

#### 3. AST 转换 (ast.ts)

```typescript
import { parser } from "./parser";
import { StitchLexer } from "./lexer";

export interface InstructionNode {
  type: "layout" | "theme" | "content" | "edit" | "details";
  param?: string;     // Content/Edit 的参数，如 "Header"
  content: string;    // 标签后的文本内容
}

export interface StitchAST {
  instructions: InstructionNode[];
}

export function parse(input: string): StitchAST {
  // 1. 词法分析
  const lexResult = StitchLexer.tokenize(input);

  if (lexResult.errors.length > 0) {
    console.warn("Lexer errors:", lexResult.errors);
  }

  // 2. 语法分析
  parser.input = lexResult.tokens;
  const cst = parser.instructions();

  if (parser.errors.length > 0) {
    console.warn("Parser errors:", parser.errors);
  }

  // 3. CST → AST 转换
  return cstToAst(cst);
}

function cstToAst(cst: any): StitchAST {
  // CST visitor 实现...
  // 将 Chevrotain 的 CST 转换为我们的 AST 结构
}
```

#### 4. 使用示例

```typescript
import { parse } from "./compiler/frontend/ast";

const input = `
[Layout] Dashboard 布局，顶部统计卡片，下方数据表格
[Theme] 企业蓝，专业简洁
[Content - Header] 标题"用户管理"，右侧"新增用户"按钮
[Content - Stats] 四个统计卡片：总用户数、活跃用户、新增用户、付费用户
[Content - Table] 用户列表表格，列：头像、姓名、邮箱、状态、操作
`;

const ast = parse(input);
// {
//   instructions: [
//     { type: "layout", content: "Dashboard 布局，顶部统计卡片，下方数据表格" },
//     { type: "theme", content: "企业蓝，专业简洁" },
//     { type: "content", param: "Header", content: "标题"用户管理"..." },
//     { type: "content", param: "Stats", content: "四个统计卡片..." },
//     { type: "content", param: "Table", content: "用户列表表格..." },
//   ]
// }
```

---

### 语法扩展性

Chevrotain 的优势在于语法定义是**运行时代码**，扩展非常方便：

```typescript
// 添加新标签只需：
// 1. 定义新 Token
export const InteractionTag = createToken({
  name: "InteractionTag",
  pattern: /\[Interaction\]/
});

// 2. 加入 Token 列表
allTokens.push(InteractionTag);

// 3. 添加 Parser 规则
private interactionInstruction = this.RULE("interactionInstruction", () => {
  this.CONSUME(InteractionTag);
  this.OPTION(() => this.CONSUME(TextContent));
});
```

无需重新生成代码，无需额外构建步骤。

---

## 下一步

1. **安装 Chevrotain**：`npm install chevrotain`
2. **实现词法分析器**：解析 `[Layout]` `[Content]` 等标签
3. **实现设计系统合成器**：Hash 种子 + Session State
4. **实现幻觉校对器**：基础的文本比对
5. **重构现有渲染器**：作为 React 后端集成到编译器中

# Stitch UI 编译器架构设计

## 概述

Stitch 不是一个简单的"JSON 转 HTML"渲染器，而是一个完整的 **UI 编译器**。

它的职责是：将**精准 DSL**（经过规划层 Agent 处理、文字绝对精准的源代码）编译为工程级可交付的 Web 资源。

```
精准 DSL  →  编译器  →  工程级代码 (HTML/React/HEEx)
```

---

## 核心流水线："两路并行，汇合出货"

```
┌─────────────────────────────────────────────────────────────────┐
│  输入源 (The Source)                                             │
│  经过"二阶段 Agent"处理后的精准 DSL                              │
│  (包含 context 和具体的 layout/content 指令)                     │
└───────────────────────────┬─────────────────────────────────────┘
                            │
            ┌───────────────┴───────────────┐
            ▼                               ▼
┌───────────────────────┐       ┌───────────────────────┐
│  支线 A: 视觉引擎      │       │  支线 B: 逻辑解析      │
│  (Visual Engine)      │       │  (Logic Parser)       │
│                       │       │                       │
│  context + hash       │       │  DSL → Token → AST    │
│       ↓               │       │       ↓               │
│  Design Tokens        │       │  结构骨架             │
│  (色阶/间距/圆角)     │       │  (组件树)             │
└───────────┬───────────┘       └───────────┬───────────┘
            │       ┌───────────────────────┘
            │       │
            ▼       ▼
┌─────────────────────────────────────────────────────────────────┐
│  汇合点: 组件工厂 (Component Factory)                            │
│                                                                  │
│  组装: AST 逻辑零件 + Token 油漆                                 │
│  映射: 指令 → React 组件实例                                     │
└───────────────────────────┬─────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  最终出口: SSR 引擎                                              │
│                                                                  │
│  拍扁: React 树 → HTML                                          │
│  瘦身: Purge 未使用 CSS                                         │
│  交付: Canvas 画面 / 静态文件                                    │
└─────────────────────────────────────────────────────────────────┘
```

**为什么这个架构无懈可击**：
- **没有废话**：输入端 DSL 已是精准的真理，无需事后校对
- **极致速度**：视觉和逻辑并行执行，互不干扰
- **绝对可控**：所有变数在进入工厂前被量化为 Tokens 和 AST 节点

---

## 详细架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           输入层 (Input Layer)                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ session_id  │  │  context    │  │ description │  │   schema    │    │
│  │ 会话标识    │  │ 语义种子    │  │ 自然语言指令 │  │ 结构化数据  │    │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘    │
└─────────┼────────────────┼────────────────┼────────────────┼───────────┘
          │                │                │                │
          ▼                ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    逻辑综合层 (Logic Synthesis Layer)                    │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    1. 词法分析器 (Lexer) - Chevrotain              │   │
│  │    解析 [Layout] [Theme] [Content] 等标签，生成 Token 流          │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    2. 语法分析器 (Parser) - Chevrotain             │   │
│  │    将 Token 流构建为 CST/AST                                      │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    3. 语义收敛器 (Semantic Normalizer) - Zod       │   │
│  │    内容解析 + 别名映射 + 默认值补全 + 嵌套校验                     │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  │ AST
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        中端层 (Middle Layer)                             │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                 4. 设计系统合成器 (Design System Synthesizer)     │   │
│  │                                                                   │   │
│  │    context + session_id → getOrCreateDesignSystem()               │   │
│  │                                → Design Tokens (CSS Variables)    │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    5. IR 生成器 (IR Generator)                    │   │
│  │    AST + Tokens → 中间表示 (Intermediate Representation)          │   │
│  │    UINode JSON 就是我们的 IR                                      │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    6. 优化器 (Optimizer)                          │   │
│  │    - 样式去重 (CSS Deduplication)                                 │   │
│  │    - 组件合并 (Component Folding)                                 │   │
│  │    - 死代码消除 (Dead Code Elimination)                           │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  │ Optimized IR
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        后端层 (Backend Layer)                            │
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    7. 代码生成器 (Code Generator)                 │   │
│  │                                                                   │   │
│  │    IR → 目标代码，支持多种后端：                                   │   │
│  │                                                                   │   │
│  │    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │   │
│  │    │ React 后端  │  │ HTML 后端   │  │ HEEx 后端   │             │   │
│  │    │ (实时预览)  │  │ (静态导出)  │  │ (Phoenix)   │             │   │
│  │    └─────────────┘  └─────────────┘  └─────────────┘             │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
│                                 ▼                                        │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │                    8. 资源打包器 (Bundler)                        │   │
│  │    - CSS 提取与压缩                                               │   │
│  │    - 图标/字体内联                                                │   │
│  │    - 临界 CSS 注入                                                │   │
│  └──────────────────────────────┬───────────────────────────────────┘   │
└─────────────────────────────────┼───────────────────────────────────────┘
                                  ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           输出层 (Output Layer)                          │
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │  React DOM  │  │ HTML 文件   │  │  PNG/PDF    │  │  HEEx 代码  │    │
│  │  (Canvas)   │  │ (下载)      │  │  (快照)     │  │  (Phoenix)  │    │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 模块详解

### 1. 词法分析器 (Lexer)

**职责**：将 description 中的自然语言指令解析为 Token 流。

**输入**：
```
[Layout] Dashboard 布局，顶部统计卡片
[Content - Header] 标题"用户管理"，按钮"新增"
[Theme] 企业风格，主色蓝色
```

**输出**：
```
[LAYOUT_TAG, "Dashboard 布局，顶部统计卡片"]
[CONTENT_TAG, "Header", "标题"用户管理"，按钮"新增""]
[THEME_TAG, "企业风格，主色蓝色"]
```

---

### 2. 语法分析器 (Parser)

**职责**：将 Token 流构建为抽象语法树 (AST)。

**输出 AST**：
```
PageNode
├── LayoutNode (type: "dashboard")
├── ThemeNode (style: "enterprise", primary: "blue")
└── ContentNode
    ├── HeaderNode
    │   ├── TitleNode (text: "用户管理")
    │   └── ButtonNode (text: "新增")
    └── ...
```

---

### 3. 语义分析器 (Semantic Analyzer)

**职责**：校验 AST 的合法性。

**检查项**：
- 组件嵌套是否合法（Table 不能直接放在 Button 里）
- 必填属性是否存在（StatisticCard 必须有 label 和 value）
- 类型是否匹配（columns 必须是数字）
- 引用是否存在（icon="xxx" 必须是合法的图标名）

**输出**：校验通过的 AST，或错误列表。

---

### 4. 设计系统合成器 (Design System Synthesizer)

**职责**：根据 context 和 session_id 生成 Design Tokens。

**核心机制**：
```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   context = "医疗健康App，专业可信"                      │
│                 │                                       │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  1. 语义约束 (Semantic)     │                      │
│   │     "医疗" → 蓝绿色相区间   │                      │
│   │     "专业" → 低饱和度范围   │                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  2. Hash 定位 (Hashing)     │                      │
│   │     hash(context) = 0x3A7F  │                      │
│   │     hue = 150 + (hash % 50) │                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  3. 色阶生成 (Scale Gen)    │                      │
│   │     primary-50 ~ primary-950│                      │
│   └─────────────┬───────────────┘                      │
│                 ▼                                       │
│   ┌─────────────────────────────┐                      │
│   │  4. Session 锁定 (Lock)     │                      │
│   │     存入 SessionState       │                      │
│   │     后续页面强制继承        │                      │
│   └─────────────────────────────┘                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**输出**：Design Tokens (CSS Variables)
```css
:root {
  --primary: hsl(178, 52%, 43%);
  --primary-50: hsl(178, 52%, 95%);
  --primary-100: hsl(178, 52%, 85%);
  ...
  --radius: 8px;
  --spacing-unit: 4px;
}
```

---

### 5. IR 生成器 (IR Generator)

**职责**：将 AST + Design Tokens 转换为中间表示 (IR)。

我们的 **UINode JSON 就是 IR**：
```json
{
  "type": "Layout",
  "props": { "direction": "column" },
  "style": { "theme": "medical", "tokens": {...} },
  "children": [...]
}
```

---

### 6. 优化器 (Optimizer)

**职责**：优化 IR，减少冗余。

**优化项**：
- **样式去重**：多个组件用同一颜色，只定义一次 CSS 变量
- **组件合并**：连续的 Text 节点合并为一个
- **死代码消除**：移除 `display: none` 的组件

---

### 7. 代码生成器 (Code Generator)

**职责**：将 IR 转换为目标代码。

**支持的后端**：

| 后端 | 用途 | 输出 |
|------|------|------|
| React | 实时预览 | React 组件树 |
| HTML | 静态导出 | HTML + CSS 文件 |
| HEEx | Phoenix 集成 | HEEx 模板代码 |
| Image | 快照导出 | PNG/PDF |

---

### 8. 资源打包器 (Bundler)

**职责**：打包最终资源。

**功能**：
- CSS 提取与压缩
- 临界 CSS 内联到 `<head>`
- 图标 SVG 内联
- 字体子集化

---

## 增量编译 (Edit Design)

当用户修改设计时，不需要全量重新编译：

```
Edit 指令: [Edit - Table] 新增一列"登录时间"
                │
                ▼
        ┌───────────────┐
        │  Diff 计算器   │  比对新旧 AST
        └───────┬───────┘
                │
                ▼
        ┌───────────────┐
        │  增量更新      │  只更新 Table 节点
        └───────┬───────┘
                │
                ▼
        ┌───────────────┐
        │  Patch 生成    │  生成最小化补丁
        └───────────────┘
```

---

## 目录结构

```
src/lib/compiler/
├── frontend/                 # 逻辑综合层
│   ├── lexer.ts             # 词法分析器
│   ├── parser.ts            # 语法分析器
│   ├── semantic.ts          # 语义分析器
│   └── ast.ts               # AST 类型定义
│
├── middle/                   # 中端层
│   ├── synthesizer.ts       # 设计系统合成器
│   ├── session.ts           # Session State 管理
│   ├── ir.ts                # IR 生成器
│   └── optimizer.ts         # 优化器
│
├── backend/                  # 后端层
│   ├── codegen/
│   │   ├── react.tsx        # React 后端
│   │   ├── html.ts          # HTML 后端
│   │   └── heex.ts          # HEEx 后端
│   └── bundler.ts           # 资源打包器
│
├── themes/                   # 主题系统（已有）
│   ├── tokens.ts
│   ├── presets.ts
│   └── override.ts
│
└── index.ts                  # 编译器入口
```

---

## API 设计

```typescript
// 编译器入口
const compiler = new StitchCompiler();

// 完整编译
const result = await compiler.compile({
  sessionId: "sess_001",
  context: "医疗健康App，专业可信",
  description: "[Layout] Dashboard... [Content] ...",
  schema: {...},
});

// 增量编译
const patch = await compiler.patch({
  sessionId: "sess_001",
  screenId: "screen_001",
  edits: "[Edit - Table] 新增一列",
});

// 导出
await compiler.export(result, { format: "html" });
await compiler.export(result, { format: "png", scale: 2 });
```

---

## 与渲染器的区别

| 维度 | 渲染器 (Renderer) | 编译器 (Compiler) |
|------|------------------|------------------|
| 输入 | 结构化 JSON | 非结构化意图 + JSON |
| 分析 | 无 | 词法/语法/语义分析 |
| 优化 | 无 | 样式去重/组件合并 |
| 状态 | 无状态 | Session State |
| 校验 | 无 | 幻觉检测/内容校对 |
| 输出 | 单一格式 | 多后端支持 |
| 增量 | 全量渲染 | 增量编译 |

---

## 补充机制

### Session State 继承（第二级约束）

在设计系统合成器中，需要实现会话级状态锁定：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Session State Manager                         │
│                                                                  │
│  首次渲染:                                                        │
│    sessionStore.has(sessionId) == false                          │
│         ↓                                                        │
│    theme = matchTheme(context)                                   │
│         ↓                                                        │
│    sessionStore.set(sessionId, { theme, context, lockedAt })     │
│         ↓                                                        │
│    返回 theme（新创建）                                           │
│                                                                  │
│  后续渲染:                                                        │
│    sessionStore.has(sessionId) == true                           │
│         ↓                                                        │
│    返回 sessionStore.get(sessionId).theme（强制继承）             │
│         ↓                                                        │
│    忽略传入的 context（即使有差异）                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**作用**：即使规划层传入的 context 有微小差异（空格、大小写），也能保证同一 Session 下的所有页面使用相同主题。

---

### AST Diff 计算（增量编译）

处理 `[Edit - xxx]` 指令时，不重新编译整个页面：

```
┌─────────────────────────────────────────────────────────────────┐
│                      AST Diff Engine                             │
│                                                                  │
│  输入:                                                           │
│    - 旧 AST (从 screen_xxx.json 读取)                            │
│    - Edit 指令 ([Edit - Table] 新增一列)                          │
│                                                                  │
│  处理:                                                           │
│    1. 定位目标节点 (type == "Table")                              │
│    2. 解析修改意图 (新增列)                                       │
│    3. 生成 Patch 对象                                            │
│                                                                  │
│  输出:                                                           │
│    {                                                             │
│      "op": "add",                                                │
│      "path": "/children/2/props/columns/-",                      │
│      "value": { "key": "lastLogin", "label": "最后登录" }        │
│    }                                                             │
│                                                                  │
│  应用:                                                           │
│    applyPatch(oldAST, patch) → newAST                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 错误恢复机制

编译器遇到错误时的降级策略：

| 阶段 | 错误类型 | 处理方式 |
|------|---------|---------|
| 词法分析 | 标签不识别 | 跳过该标签，记录警告，继续解析 |
| 语法分析 | 结构不完整 | 尝试自动补全，插入空节点 |
| 语义分析 | 组件嵌套非法 | 自动调整为合法结构（如 Button 包 Table → 提升 Table） |
| 设计合成 | 主题匹配失败 | 降级到默认主题 (tech) |
| 代码生成 | 组件未注册 | 渲染为占位符 + 错误提示 |

---

### Platform 分支处理

在 Component Factory 层，根据 platform 执行不同的编排逻辑：

```
┌─────────────────────────────────────────────────────────────────┐
│                    Platform Adapter                              │
│                                                                  │
│  if platform == "web":                                           │
│    - 允许 Grid 多列布局                                          │
│    - 允许侧边栏导航                                              │
│    - 屏幕比例 16:9                                               │
│                                                                  │
│  if platform == "mobile":                                        │
│    - 强制垂直 Stack 布局                                         │
│    - 注入底部 TabBar（如果 mobile_navigation 存在）              │
│    - 屏幕比例 9:16                                               │
│    - 调整间距比例（更紧凑）                                      │
│    - 字体稍大（触控友好）                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 规划层与编译器的协作

### 核心架构："单脑多手"

这是一个**"集权规划，分权渲染"**的架构：

- **规划层（AI）**：唯一的"大脑"，一次性规划所有页面，输出 DSL
- **编译器（代码）**：多个并行的"翻译机器"，确定性地把 DSL 变成页面

```
┌─────────────────────────────────────────────────────────────────┐
│  用户输入                                                        │
│  "做一个 5 页的技术分享 PPT"                                     │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI（单个大脑）                                            │
│                                                                  │
│  一次性思考，输出 5 份 JSON（每份包含一页的 DSL）：                │
│                                                                  │
│  [                                                               │
│    {                                                             │
│      "title": "封面",                                            │
│      "context": "技术分享PPT，企业风格",                          │
│      "description": "[Layout] Hero 布局\n[Content] 标题'架构'..."│
│    },                                                            │
│    {                                                             │
│      "title": "第2页",                                           │
│      "context": "技术分享PPT，企业风格",  ← 同样的 context        │
│      "description": "[Layout] 两栏布局\n[Content - Left]..."    │
│    },                                                            │
│    ... (共 5 份)                                                 │
│  ]                                                               │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  分发层（调度器）                                                 │
│                                                                  │
│  接收 5 份 JSON，分发给 5 个编译器实例并行处理                    │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  编译器层（纯代码，不是 AI）                                      │
│                                                                  │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │编译器 1 │ │编译器 2 │ │编译器 3 │ │编译器 4 │ │编译器 5 │   │
│  │ P1.json │ │ P2.json │ │ P3.json │ │ P4.json │ │ P5.json │   │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘   │
│       ↓           ↓           ↓           ↓           ↓         │
│    P1.html    P2.html    P3.html    P4.html    P5.html         │
│                                                                  │
│  因为不思考，所以极速并行                                        │
│  因为不思考，所以绝对忠诚（色号一致、风格统一）                   │
└─────────────────────────────────────────────────────────────────┘
```

### 为什么不用"多个 AI Agent 并行"？

| 方案 | 问题 |
|------|------|
| 5 个 AI 分头写 | 风格会打架（AI 有随机性） |
| 5 个 AI 分头写 | 成本高、速度慢 |
| 5 个 AI 分头写 | 逻辑断层（不理解整体起承转合） |
| **1 个 AI + 5 个编译器** | ✅ 风格统一、极速、确定性 |

### 数据流详解

```
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI 输出的 JSON 结构                                      │
│                                                                  │
│  {                                                               │
│    "function_call": "generate_design",                          │
│    "arguments": {                                                │
│      "title": "用户管理",                                        │
│      "context": "医疗健康App，企业风格",    ← Hash 种子          │
│      "description": "..."                   ← DSL 在这里        │
│    }                                                             │
│  }                                                               │
│                                                                  │
│  JSON 是"壳"，DSL 是"核"                                        │
│  - title/context：元信息，告诉编译器"用哪套主题"                 │
│  - description：真正的布局图纸                                   │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  description 字段里的 DSL（结构化标签格式）                       │
│                                                                  │
│  [SECTION: Execution_Flow]                                       │
│    { Gutter: "32px", Align: "Center" }                          │
│    [CARD: node_opencode]                                         │
│      ATTR: Title("OpenCode 接口调用"), Icon("Terminal")          │
│      CONTENT: "执行层通过 handle_opencode_call/7 订阅 SSE 事件"  │
│      [BUTTON: "运行调试"]                                        │
│        ATTR: Variant("Outline"), Size("Small")                   │
│                                                                  │
│  DSL 语法特点：                                                  │
│  - [TAG: id_or_text] 定义节点，冒号后是 ID 或显示文本            │
│  - { key: "value" } 定义布局属性                                │
│  - ATTR: Key("value") 定义组件属性                              │
│  - CONTENT: "..." 定义文本内容                                  │
│  - 缩进表示父子关系                                             │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  编译器输出：标准化 AST（直接喂给组件工厂）                       │
│                                                                  │
│  {                                                               │
│    "type": "Root",                                               │
│    "children": [                                                 │
│      {                                                           │
│        "id": "node_section_1",                                   │
│        "type": "Section",                                        │
│        "props": { "gutter": "32px", "align": "center" },        │
│        "children": [                                             │
│          {                                                       │
│            "id": "node_opencode",                                │
│            "type": "Card",                                       │
│            "props": { "title": "OpenCode 接口调用",             │
│                       "icon": "Terminal" },                      │
│            "children": [                                         │
│              { "type": "Text",                                   │
│                "props": { "content": "执行层通过..." } },       │
│              { "id": "node_btn_1",                               │
│                "type": "Button",                                 │
│                "props": { "text": "运行调试",                   │
│                           "variant": "outline",                  │
│                           "size": "small" } }                    │
│            ]                                                     │
│          }                                                       │
│        ]                                                         │
│      }                                                           │
│    ]                                                             │
│  }                                                               │
│                                                                  │
│  核心设计：                                                      │
│  - type: 直接对应 Registry["Section"] 查找组件                  │
│  - props: 直接透传给 React 组件                                 │
│  - id: 从 [CARD: node_opencode] 提取，用于锚点/调试             │
│  - 内容无损：精准文本原封不动进入 props.content                  │
│  - 布局与样式解耦：AST 只定义结构，像素值由工厂层动态注入        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### DSL 与 AST 的关系

| 层级 | 格式 | 谁生成 | 用途 |
|------|------|--------|------|
| **DSL** | `[TAG: id] { props } ATTR: ... CONTENT: ...` | 规划层 AI | 给编译器的输入 |
| **AST** | `{ type, id, props, children }` 结构 | 编译器（Chevrotain + Zod） | 给组件工厂的输入 |

AI 输出结构化 DSL，编译器转成标准化 AST（直接喂给 React）。

### 逻辑综合层的处理流程

编译器分三步处理 DSL：

```
┌─────────────────────────────────────────────────────────────────┐
│                    逻辑综合层处理流程                            │
│                                                                  │
│  输入 DSL：                                                      │
│  [CARD: node_opencode]                                          │
│    ATTR: Title("OpenCode 接口调用"), Icon("Terminal")           │
│    CONTENT: "执行层通过 handle_opencode_call/7 订阅 SSE 事件"   │
│    [BUTTON: "运行调试"]                                         │
│      ATTR: Variant("Outline"), Size("Small")                    │
│                                                                  │
│  Step 1: 标记化 (Chevrotain Lexer)                              │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 识别 TOKEN 流：                                      │     │
│     │ [CARD_TAG, COLON, ID("node_opencode"), NEWLINE,     │     │
│     │  ATTR, COLON, FUNC("Title"), LPAREN, STRING, ...]   │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  Step 2: 语法分析 (Chevrotain Parser)                           │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ 构建 CST (Concrete Syntax Tree)：                   │     │
│     │ { tag: "CARD", id: "node_opencode",                 │     │
│     │   attrs: [{ key: "Title", value: "OpenCode..." }],  │     │
│     │   content: "执行层通过...",                         │     │
│     │   children: [{ tag: "BUTTON", ... }] }              │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  Step 3: 语义收敛 (Zod Transform)                               │
│     ┌─────────────────────────────────────────────────────┐     │
│     │ a. 属性收敛：                                       │     │
│     │    Variant("Outline") → variant: "outline"         │     │
│     │    Size("Small")      → size: "small"              │     │
│     │                                                     │     │
│     │ b. 默认值补全：                                     │     │
│     │    Button 没指定 variant → 默认 "primary"          │     │
│     │                                                     │     │
│     │ c. 别名映射：                                       │     │
│     │    Align("Center") → align: "center"               │     │
│     └─────────────────────────────────────────────────────┘     │
│                                                                  │
│  输出 AST：                                                      │
│  {                                                               │
│    "id": "node_opencode",                                       │
│    "type": "Card",                                              │
│    "props": { "title": "OpenCode 接口调用", "icon": "Terminal" },│
│    "children": [                                                 │
│      { "type": "Text", "props": { "content": "执行层通过..." } },│
│      { "id": "node_btn_1", "type": "Button",                    │
│        "props": { "text": "运行调试", "variant": "outline",     │
│                   "size": "small" } }                           │
│    ]                                                             │
│  }                                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 技术选型：语义收敛

### 为什么用 Zod 而不是 NLP 库

| 对比项 | Compromise/Natural (NLP) | Zod |
|--------|--------------------------|-----|
| **设计目标** | 处理自然语言文本 | 处理结构化数据 |
| **输入** | "我要一个蓝色按钮" | `{ color: "BLUE" }` |
| **输出** | 概率性（可能识别错） | 确定性（转换规则明确） |
| **性能** | 较慢（需要分词、标注） | 快（直接查表） |
| **依赖** | 较重（词典、模型文件） | 轻量（纯 JS） |
| **类型安全** | 无 | 完美 TypeScript 支持 |

**核心原因**：规划层 AI 输出的已经是结构化 DSL，不是自然语言。

```
自然语言: "我要一个蓝色按钮"     ← 需要 NLP 理解（规划层做）
结构化:   ATTR: COLOR(BLUE)      ← 只需要 Map 查表（编译器做）
```

对于结构化输入，用 NLP 是**杀鸡用牛刀**。

---

## 视觉引擎架构

### 核心定位：视觉物理规律 (Visual Physics)

视觉引擎不只是"算几个色号"，它在为整个页面构建一套**视觉物理规律**。

**与逻辑层的关系**：样式与逻辑分离

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  第一层：逻辑综合层              第二层：视觉引擎                │
│  ────────────────────           ────────────────────            │
│  处理"是什么"和"在哪里"          处理"整体感觉"                  │
│                                                                  │
│  输入: DSL                       输入: context + hash seed      │
│  输出: AST (结构树)              输出: Design Tokens (CSS 变量)  │
│                                                                  │
│       │                               │                          │
│       └───────────┬───────────────────┘                          │
│                   ▼                                              │
│          第三层：组件工厂                                        │
│          把"皮肤"贴在"骨头"上                                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

这种并行架构的意义：
同一套逻辑树（AST），只要换一个视觉引擎的 Hash 种子，
就能瞬间从"严谨的金融后台"变成"活泼的社交 App"。
```

---

### 视觉引擎的 5 个控制维度

除了颜色，视觉引擎基于 Hash 种子动态生成一整套 Design Tokens，控制以下 5 个关键维度：

#### A. 空间尺度系统 (Spacing & Sizing Scale) — "呼吸感"

决定页面的"呼吸感"，即元素之间的空间松紧程度。

**Hash 影响**：决定基础步长（4px / 6px / 8px）和间距系数

**具体 CSS 属性**：

| 属性 | 紧凑 (0.8x) | 标准 (1.0x) | 宽松 (1.5x) |
|------|------------|------------|------------|
| `--base-unit` | 4px | 8px | 8px |
| `--spacing-xs` | 2px | 4px | 6px |
| `--spacing-sm` | 4px | 8px | 12px |
| `--spacing-md` | 8px | 16px | 24px |
| `--spacing-lg` | 12px | 24px | 36px |
| `--spacing-xl` | 16px | 32px | 48px |
| `--gap-card` | 8px | 16px | 24px |
| `--padding-card` | 12px | 16px | 24px |
| `--padding-section` | 16px | 24px | 40px |
| `--line-height-body` | 1.4 | 1.5 | 1.75 |

**场景示例**：

```
紧凑型（金融后台）                宽松型（营销页面）
┌────────────────────┐           ┌────────────────────────────┐
│┌────┐┌────┐┌────┐ │           │                            │
││统计││统计││统计│ │           │  ┌──────┐    ┌──────┐     │
│└────┘└────┘└────┘ │           │  │ 统计 │    │ 统计 │     │
│┌──────────────────┐│           │  └──────┘    └──────┘     │
││     数据表格     ││           │                            │
│└──────────────────┘│           │  ┌──────┐    ┌──────┐     │
└────────────────────┘           │  │ 统计 │    │ 统计 │     │
                                 │  └──────┘    └──────┘     │
信息密度高，适合专业用户          └────────────────────────────┘
                                 留白充足，适合浏览型场景
```

#### B. 字体排版系统 (Typography System)

**Hash 影响**：决定字阶比率（Modular Scale）

**字阶比率说明**：

| 比率 | 名称 | 适用场景 | H1 相对 body |
|------|------|---------|-------------|
| 1.125 | Major Second | 紧凑界面、数据密集 | 1.42x |
| 1.25 | Major Third | 企业应用、正文为主 | 1.95x |
| 1.333 | Perfect Fourth | 博客、文档 | 2.37x |
| 1.5 | Perfect Fifth | 营销页面 | 3.38x |
| 1.618 | Golden Ratio | 品牌展示、艺术感 | 4.24x |

**具体 CSS 属性**：

```css
/* 字阶比率 1.25 (Major Third) 示例 */
:root {
  --font-scale: 1.25;
  --font-size-xs: 0.64rem;    /* 10.24px */
  --font-size-sm: 0.8rem;     /* 12.8px */
  --font-size-base: 1rem;     /* 16px */
  --font-size-lg: 1.25rem;    /* 20px */
  --font-size-xl: 1.563rem;   /* 25px */
  --font-size-2xl: 1.953rem;  /* 31.25px */
  --font-size-3xl: 2.441rem;  /* 39px */

  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
}
```

#### C. 形状与边框规范 (Shape & Elevation)

**Hash 影响**：决定圆角弧度和阴影深度

**具体 CSS 属性**：

| 风格 | 圆角 | 阴影 | 适用场景 |
|------|------|------|---------|
| 硬朗 | 0-4px | 浓重 | 金融、法务 |
| 中性 | 6-8px | 中等 | 企业应用 |
| 柔和 | 12-16px | 轻盈 | 消费品、社交 |
| 胶囊 | 9999px | 极轻 | 儿童、创意 |

```css
/* 硬朗风格 */
:root {
  --radius-sm: 2px;
  --radius-md: 4px;
  --radius-lg: 6px;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  --shadow-md: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
  --shadow-lg: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
}

/* 柔和风格 */
:root {
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --radius-full: 9999px;

  --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 8px rgba(0,0,0,0.06);
  --shadow-lg: 0 8px 16px rgba(0,0,0,0.08);
}
```

#### D. 装饰性元元素 (Ornamentation)

**作用**：决定是否在背景中加入微妙的纹理，增强氛围感

**具体 CSS 属性**：

```css
:root {
  /* 点阵纹理 */
  --pattern-dots: radial-gradient(circle, rgba(0,0,0,0.03) 1px, transparent 1px);
  --pattern-dots-size: 20px 20px;

  /* 网格纹理 */
  --pattern-grid: linear-gradient(rgba(0,0,0,0.02) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px);
  --pattern-grid-size: 24px 24px;

  /* 渐变遮罩 */
  --gradient-fade: linear-gradient(180deg, transparent 0%, var(--background) 100%);

  /* 噪点纹理（通过 SVG filter 或图片） */
  --noise-opacity: 0.03;
}

/* 应用示例 */
.section-background {
  background-image: var(--pattern-dots);
  background-size: var(--pattern-dots-size);
}
```

**场景控制**：

| 场景 | 纹理类型 | 强度 |
|------|---------|------|
| 技术/金融 | 无或极淡网格 | 0-0.02 |
| 企业应用 | 淡点阵 | 0.02-0.03 |
| 创意/营销 | 渐变+噪点 | 0.03-0.05 |
| 儿童/活泼 | 彩色点阵/波纹 | 0.05-0.08 |

#### E. 语义映射转换 (Semantic Mapping)

**作用**：把抽象指令 `COLOR(BLUE)` 转换为场景特定的色值

```
┌─────────────────────────────────────────────────────────────────┐
│  COLOR(BLUE) 在不同场景的映射                                    │
│                                                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ 技术调研        │  │ 儿童教育        │  │ 医疗健康        │  │
│  │                 │  │                 │  │                 │  │
│  │  ████████████   │  │  ████████████   │  │  ████████████   │  │
│  │  #1E40AF       │  │  #60A5FA       │  │  #0891B2       │  │
│  │  深邃蓝        │  │  天空蓝        │  │  青蓝          │  │
│  │                 │  │                 │  │                 │  │
│  │  特征:         │  │  特征:         │  │  特征:         │  │
│  │  深邃、专业    │  │  活泼、明亮    │  │  清洁、可信    │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 视觉引擎的输出

最终产出的不是图片，而是一张 **CSS 变量表**：

```css
:root {
  /* A. 空间尺度 */
  --base-unit: 8px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --gap-card: 16px;
  --padding-card: 16px;
  --line-height-body: 1.5;

  /* B. 字体排版 */
  --font-scale: 1.25;
  --font-size-base: 16px;
  --font-size-lg: 20px;
  --font-size-xl: 25px;
  --font-weight-heading: 600;

  /* C. 形状边框 */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.07);

  /* D. 装饰纹理 */
  --pattern-dots: radial-gradient(...);
  --noise-opacity: 0.02;

  /* E. 语义颜色 */
  --primary-color: #1a73e8;
  --primary-50: #eff6ff;
  --primary-100: #dbeafe;
  /* ... 完整色阶 */
}
```

---

### 为什么这样设计很重要

**设计变得"可计算"**：

1. **确定性**：同一项目，无论生成几次，间距和颜色永远对齐
2. **动态性**：只需改动一个 Seed，整套 UI 的"性格"会发生翻天覆地的变化
3. **可复现**：`hash(context + session_id)` 保证同样输入 → 同样输出

如果只是写死几个 Preset，那就不叫编译器。视觉引擎让设计从"选模板"变成"算出来"。

---

## 组件工厂层 (Component Factory)

### 核心定位

组件工厂是编译器的**第三层**，负责把"骨头"（AST）和"皮肤"（Design Tokens）组装成活的 React 组件树。

```
┌─────────────────────────────────────────────────────────────────┐
│  如果把 UI 比作一辆车：                                          │
│                                                                  │
│  规划层      → 图纸                                              │
│  视觉引擎    → 调色漆和选内饰                                    │
│  工厂层      → 组装车间                                          │
│               ├─ 零件匹配：把图纸上的"轮子"对应到"米其林轮胎"    │
│               ├─ 灌浆组装：把零件焊在一起（构建 DOM 树）         │
│               ├─ 通电测试：接通电路（绑定交互事件）              │
│               └─ 最后喷漆：根据内饰方案刷漆（注入 Design Tokens）│
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 输入与输出

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  输入                                                            │
│  ────                                                            │
│  1. AST (来自逻辑综合层)                                         │
│     {                                                            │
│       type: "Section",                                           │
│       props: { gutter: "32px", align: "center" },               │
│       children: [                                                │
│         { type: "Card", props: { title: "...", icon: "..." } }, │
│         { type: "Table", props: { columns: [...] } }            │
│       ]                                                          │
│     }                                                            │
│                                                                  │
│  2. Design Tokens (来自视觉引擎)                                 │
│     {                                                            │
│       "--primary-color": "#1a73e8",                             │
│       "--spacing-md": "16px",                                   │
│       "--radius-md": "8px",                                     │
│       ...                                                        │
│     }                                                            │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  输出                                                            │
│  ────                                                            │
│  React 组件树 (可直接渲染的 ReactNode)                           │
│                                                                  │
│  <ThemeProvider tokens={designTokens}>                          │
│    <Page>                                                        │
│      <Header>                                                    │
│        <Title>用户管理</Title>                                   │
│        <Button onClick={stub}>新增用户</Button>                  │
│      </Header>                                                   │
│      <Table columns={normalizedColumns} />                      │
│    </Page>                                                       │
│  </ThemeProvider>                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 四大核心职责

#### 1. 属性转换与归一化 (Props Normalization)

规划层发出的 DSL 参数是**语义化**的，底层 React 组件需要的是**具体值**。

```
┌─────────────────────────────────────────────────────────────────┐
│  DSL 语义参数              →              React 具体值           │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  size: "large"            →    className="text-lg p-4"          │
│  size: "small"            →    className="text-sm p-2"          │
│                                                                  │
│  spacing: "compact"       →    className="p-2 gap-1"            │
│  spacing: "comfortable"   →    className="p-4 gap-3"            │
│                                                                  │
│  color: "primary"         →    style={{ color: tokens.primary }}│
│  color: "danger"          →    style={{ color: tokens.danger }} │
│                                                                  │
│  variant: "outlined"      →    className="border border-primary │
│                                           bg-transparent"       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
function transformProps(
  astProps: Record<string, any>,
  tokens: DesignTokens
): Record<string, any> {
  const result: Record<string, any> = {};

  // 尺寸转换
  if (astProps.size) {
    const sizeMap = {
      small: { className: "text-sm p-2", style: { fontSize: tokens["--font-size-sm"] } },
      medium: { className: "text-base p-3", style: { fontSize: tokens["--font-size-base"] } },
      large: { className: "text-lg p-4", style: { fontSize: tokens["--font-size-lg"] } },
    };
    Object.assign(result, sizeMap[astProps.size] || sizeMap.medium);
  }

  // 间距转换
  if (astProps.spacing) {
    const spacingMap = {
      compact: `gap-[${tokens["--spacing-sm"]}]`,
      comfortable: `gap-[${tokens["--spacing-md"]}]`,
      spacious: `gap-[${tokens["--spacing-lg"]}]`,
    };
    result.className = `${result.className || ""} ${spacingMap[astProps.spacing]}`;
  }

  // 颜色转换
  if (astProps.color) {
    result.style = {
      ...result.style,
      "--btn-color": tokens[`--${astProps.color}-color`] || tokens["--primary-color"],
    };
  }

  return result;
}
```

#### 2. 插槽分发与布局递归 (Slot Distribution & Recursion)

工厂层不是一次性把页面拍扁，而是**递归地**构建组件树，并处理**插槽分发**。

```
┌─────────────────────────────────────────────────────────────────┐
│  AST 子节点                        Card 组件插槽                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  children: [                       ┌─────────────────────┐      │
│    { type: "TITLE", ... },    ──→  │ header slot         │      │
│    { type: "TEXT", ... },     ──→  │ body slot           │      │
│    { type: "BUTTON", ... }    ──→  │ footer slot         │      │
│  ]                                 └─────────────────────┘      │
│                                                                  │
│  分发规则：                                                      │
│  - 带 TITLE/HEADING 的节点 → header                             │
│  - 带 BUTTON/ACTION 的节点 → footer                             │
│  - 其他节点 → body                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**条件渲染**：如果某个插槽没有内容，工厂层会自动决定不渲染该容器：

```typescript
function distributeSlots(children: ASTNode[]): SlotDistribution {
  const slots: SlotDistribution = {
    header: [],
    body: [],
    footer: [],
  };

  for (const child of children) {
    if (["TITLE", "HEADING", "BREADCRUMB"].includes(child.type)) {
      slots.header.push(child);
    } else if (["BUTTON", "ACTION", "LINK"].includes(child.type)) {
      slots.footer.push(child);
    } else {
      slots.body.push(child);
    }
  }

  return slots;
}

// 渲染时：条件渲染空插槽
function renderCard(slots: SlotDistribution) {
  return (
    <Card>
      {slots.header.length > 0 && (
        <CardHeader>{slots.header.map(render)}</CardHeader>
      )}
      <CardBody>{slots.body.map(render)}</CardBody>
      {slots.footer.length > 0 && (
        <CardFooter>{slots.footer.map(render)}</CardFooter>
      )}
    </Card>
  );
}
```

#### 3. 事件与交互的桩函数注入 (Event Stubbing)

为了让 UI 看起来"像真的"，工厂层需要注入交互逻辑。

```
┌─────────────────────────────────────────────────────────────────┐
│  桩函数注入                                                      │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  Button                                                          │
│  ├─ onClick: () => console.log("Button clicked")                │
│  ├─ onHover: 状态变化（高亮效果）                                │
│  └─ disabled 状态处理                                            │
│                                                                  │
│  Input                                                           │
│  ├─ onChange: (e) => setValue(e.target.value)                   │
│  ├─ onFocus: 聚焦样式                                            │
│  └─ onBlur: 失焦验证                                             │
│                                                                  │
│  Menu (左侧导航)                                                 │
│  ├─ onClick: (item) => setActiveItem(item)                      │
│  └─ 联动：右侧内容区根据 activeItem 变化                         │
│                                                                  │
│  Modal                                                           │
│  ├─ onOpen / onClose                                            │
│  └─ 背景遮罩点击关闭                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**状态同步逻辑**（组件间通信隧道）：

```typescript
// 在工厂层组装时，建立组件间的通信隧道
function createInteractionContext() {
  const [state, setState] = useState({
    activeMenuItem: null,
    modalOpen: false,
    selectedRows: [],
  });

  return {
    // 菜单 → 内容区联动
    onMenuClick: (item: string) => {
      setState(s => ({ ...s, activeMenuItem: item }));
    },
    getActiveContent: () => state.activeMenuItem,

    // Modal 控制
    openModal: () => setState(s => ({ ...s, modalOpen: true })),
    closeModal: () => setState(s => ({ ...s, modalOpen: false })),
    isModalOpen: () => state.modalOpen,

    // 表格行选择
    onRowSelect: (rows: string[]) => {
      setState(s => ({ ...s, selectedRows: rows }));
    },
    getSelectedRows: () => state.selectedRows,
  };
}
```

#### 4. 运行时上下文注入 (Context Injection)

这是保证页面风格一致的**最后一关**。

```
┌─────────────────────────────────────────────────────────────────┐
│  ThemeProvider 包裹整棵树                                        │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  <ThemeProvider value={designTokens}>     ← 顶层注入             │
│    │                                                             │
│    ├─ <Page>                                                    │
│    │   ├─ <Header>                                              │
│    │   │   └─ <Button />  ← useTheme() 获取 tokens              │
│    │   │                                                        │
│    │   └─ <Table>                                               │
│    │       └─ <Cell />    ← useTheme() 获取 tokens              │
│    │                                                            │
│    └─ 任何深层组件都能通过 useTheme() 知道自己该用什么颜色       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
// 创建 Theme Context
const ThemeContext = React.createContext<DesignTokens | null>(null);

// Provider 组件
export function ThemeProvider({
  tokens,
  children,
}: {
  tokens: DesignTokens;
  children: React.ReactNode;
}) {
  // 将 tokens 注入 CSS 变量
  const style = useMemo(() => {
    const vars: Record<string, string> = {};
    for (const [key, value] of Object.entries(tokens)) {
      vars[key] = value;
    }
    return vars as React.CSSProperties;
  }, [tokens]);

  return (
    <ThemeContext.Provider value={tokens}>
      <div style={style}>{children}</div>
    </ThemeContext.Provider>
  );
}

// Hook：任何组件都能获取 tokens
export function useTheme(): DesignTokens {
  const tokens = useContext(ThemeContext);
  if (!tokens) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return tokens;
}

// 使用示例：Button 组件自动获取主题色
function Button({ children, variant = "primary" }) {
  const tokens = useTheme();

  return (
    <button
      style={{
        backgroundColor: tokens[`--${variant}-color`],
        borderRadius: tokens["--radius-md"],
        padding: `${tokens["--spacing-sm"]} ${tokens["--spacing-md"]}`,
      }}
    >
      {children}
    </button>
  );
}
```

### 完整的工厂函数

把四个职责整合在一起：

```typescript
/**
 * 组件工厂：把 AST + Design Tokens 组装成 React 组件树
 */
function ComponentFactory(
  astNode: ASTNode,
  tokens: DesignTokens,
  interactionCtx: InteractionContext
): React.ReactNode {
  // 1. 找到对应的 React 组件
  const Component = ComponentRegistry.get(astNode.type);

  if (!Component) {
    console.warn(`Unknown component: ${astNode.type}`);
    return null;
  }

  // 2. 属性转换（AST Props → React Props）
  const normalizedProps = transformProps(astNode.props, tokens);

  // 3. 注入事件桩函数
  const propsWithEvents = injectEventStubs(
    normalizedProps,
    astNode.type,
    interactionCtx
  );

  // 4. 处理插槽分发（如果组件支持插槽）
  let children: React.ReactNode = null;
  if (astNode.children && astNode.children.length > 0) {
    if (Component.slots) {
      // 有插槽的组件：分发子节点到不同插槽
      const slots = distributeSlots(astNode.children, Component.slots);
      children = renderSlots(slots, tokens, interactionCtx);
    } else {
      // 普通组件：递归渲染子节点
      children = astNode.children.map((child, index) => (
        <React.Fragment key={index}>
          {ComponentFactory(child, tokens, interactionCtx)}
        </React.Fragment>
      ));
    }
  }

  // 5. 返回组装好的 React 实例
  return <Component {...propsWithEvents}>{children}</Component>;
}

/**
 * 顶层入口：包裹 ThemeProvider
 */
export function renderPage(
  ast: ASTNode,
  tokens: DesignTokens
): React.ReactNode {
  const interactionCtx = createInteractionContext();

  return (
    <ThemeProvider tokens={tokens}>
      <InteractionProvider value={interactionCtx}>
        {ComponentFactory(ast, tokens, interactionCtx)}
      </InteractionProvider>
    </ThemeProvider>
  );
}
```

### 组件注册表 (Component Registry)

工厂层需要一个**组件映射表**，把 AST 节点类型映射到真实的 React 组件：

```typescript
const ComponentRegistry = new Map<string, React.ComponentType<any>>([
  // 布局组件
  ["PAGE", Page],
  ["SECTION", Section],
  ["CARD", Card],
  ["GRID", Grid],
  ["STACK", Stack],

  // 内容组件
  ["HEADER", Header],
  ["TITLE", Title],
  ["TEXT", Text],
  ["IMAGE", Image],

  // 交互组件
  ["BUTTON", Button],
  ["INPUT", Input],
  ["SELECT", Select],
  ["CHECKBOX", Checkbox],

  // 数据展示
  ["TABLE", Table],
  ["LIST", List],
  ["STATS", StatsCard],
  ["CHART", Chart],

  // 导航组件
  ["MENU", Menu],
  ["TABS", Tabs],
  ["BREADCRUMB", Breadcrumb],

  // 反馈组件
  ["MODAL", Modal],
  ["TOAST", Toast],
  ["ALERT", Alert],
]);
```

---

## SSR 引擎层 (Server Side Rendering Engine)

### 核心定位：工业级产物导出

当组件工厂完成 React 树的组装后，SSR 引擎负责将其转化为能在浏览器里**"裸奔"**的 HTML/CSS。

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  React 组件树 (有生命力、带逻辑、带 Props)                       │
│       │                                                          │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              SSR 引擎 (Server Side Rendering)            │    │
│  │                                                          │    │
│  │  1. 脱水渲染 → 2. 样式萃取 → 3. 资源固化                │    │
│  │                                                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│       │                                                          │
│       ▼                                                          │
│  单文件 HTML (无依赖、可离线运行、加载极快)                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 三大核心职责

#### 1. 脱水渲染 (Dehydration)

把有生命力的 React 组件"拍扁"成静态 HTML 字符串。

```typescript
import { renderToString } from 'react-dom/server';

/**
 * 脱水渲染：React 组件树 → HTML 字符串
 */
function dehydrate(reactTree: React.ReactNode): string {
  // 调用 React 的服务端渲染 API
  const htmlString = renderToString(reactTree);

  return htmlString;
}

// 示例
const reactTree = (
  <ThemeProvider tokens={designTokens}>
    <Page>
      <Header>
        <Title>用户管理</Title>
        <Button>新增用户</Button>
      </Header>
      <Table columns={columns} data={data} />
    </Page>
  </ThemeProvider>
);

const html = dehydrate(reactTree);
// 输出：
// <div class="page"><div class="header"><h1>用户管理</h1>...
```

**为什么叫"脱水"？**
- React 组件是"活的"（有状态、有事件、有生命周期）
- 脱水后变成"干的"HTML 字符串（只有结构，没有行为）
- 就像把新鲜水果做成果干，保留形态，去除水分

#### 2. 样式萃取 (Critical CSS & Purging)

解决性能问题：Tailwind 等工具库有几万个 CSS 类名，但页面只用到几十个。

```
┌─────────────────────────────────────────────────────────────────┐
│  样式萃取流程                                                    │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  Tailwind 完整 CSS (几 MB)                                       │
│       │                                                          │
│       ▼                                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  PostCSS 插件扫描生成的 HTML                             │    │
│  │                                                          │    │
│  │  发现使用的类名：                                        │    │
│  │  - flex, items-center, justify-between                  │    │
│  │  - bg-white, text-gray-900, p-4                         │    │
│  │  - rounded-lg, shadow-md                                │    │
│  │  ...共 47 个                                             │    │
│  └─────────────────────────────────────────────────────────┘    │
│       │                                                          │
│       ▼ Purge (删除未使用的 99%)                                │
│                                                                  │
│  Critical CSS (几 KB)                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
import { PurgeCSS } from 'purgecss';

/**
 * 样式萃取：删除未使用的 CSS
 */
async function extractCriticalCSS(
  html: string,
  fullCSS: string
): Promise<string> {
  const purgeCSSResult = await new PurgeCSS().purge({
    content: [{ raw: html, extension: 'html' }],
    css: [{ raw: fullCSS }],
    // 保留动态类名（如 hover:、focus:）
    safelist: {
      standard: [/^hover:/, /^focus:/, /^active:/],
      deep: [/data-state/],
    },
  });

  return purgeCSSResult[0].css;
}

// 示例
const fullTailwind = await readFile('tailwind.css'); // 2.5 MB
const criticalCSS = await extractCriticalCSS(html, fullTailwind);
// 结果：约 8 KB
```

**效果对比**：

| 指标 | 未萃取 | 萃取后 |
|------|--------|--------|
| CSS 大小 | 2.5 MB | 8 KB |
| 首屏加载 | 1.2s | 0.1s |
| Lighthouse 性能分 | 65 | 98 |

#### 3. 资源固化 (Asset Solidification)

把外部依赖的资源内联到 HTML 中，生成**单文件、零依赖**的产物。

```
┌─────────────────────────────────────────────────────────────────┐
│  资源固化                                                        │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  原始引用方式                     固化后                         │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  <link href="styles.css">    →   <style>...内联CSS...</style>   │
│                                                                  │
│  <img src="logo.png">        →   <img src="data:image/png;      │
│                                        base64,...">             │
│                                                                  │
│  <i class="icon-user">       →   <svg>...内联SVG...</svg>       │
│  (Icon Font)                                                     │
│                                                                  │
│  <link href="fonts.css">     →   @font-face { src: url(data:    │
│  (Web Font)                           font/woff2;base64,...) }  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**实现方式**：

```typescript
/**
 * 资源固化：外部资源 → 内联
 */
async function solidifyAssets(html: string): Promise<string> {
  let result = html;

  // 1. CSS 内联
  result = result.replace(
    /<link[^>]+href="([^"]+\.css)"[^>]*>/g,
    (match, cssPath) => {
      const cssContent = readFileSync(cssPath, 'utf-8');
      return `<style>${cssContent}</style>`;
    }
  );

  // 2. 图片转 Base64
  result = result.replace(
    /<img[^>]+src="([^"]+\.(png|jpg|gif|webp))"[^>]*>/g,
    (match, imgPath, ext) => {
      const imgBuffer = readFileSync(imgPath);
      const base64 = imgBuffer.toString('base64');
      const mimeType = `image/${ext === 'jpg' ? 'jpeg' : ext}`;
      return match.replace(imgPath, `data:${mimeType};base64,${base64}`);
    }
  );

  // 3. SVG 图标内联
  result = await inlineSVGIcons(result);

  return result;
}

/**
 * SVG 图标内联
 */
async function inlineSVGIcons(html: string): Promise<string> {
  // 把 <i class="icon-xxx"> 替换为实际的 <svg>
  const iconPattern = /<i[^>]+class="icon-([^"]+)"[^>]*><\/i>/g;

  return html.replace(iconPattern, (match, iconName) => {
    const svgPath = `icons/${iconName}.svg`;
    if (existsSync(svgPath)) {
      return readFileSync(svgPath, 'utf-8');
    }
    return match;
  });
}
```

### 完整的 SSR 引擎

```typescript
/**
 * SSR 引擎：React 组件树 → 单文件 HTML
 */
export async function renderToStaticHTML(
  reactTree: React.ReactNode,
  options: {
    title: string;
    designTokens: DesignTokens;
    fullCSS: string;
  }
): Promise<string> {
  // 1. 脱水渲染
  const bodyHTML = renderToString(reactTree);

  // 2. 样式萃取
  const criticalCSS = await extractCriticalCSS(bodyHTML, options.fullCSS);

  // 3. Design Tokens 转 CSS 变量
  const tokenCSS = Object.entries(options.designTokens)
    .map(([key, value]) => `  ${key}: ${value};`)
    .join('\n');

  // 4. 组装完整 HTML
  let html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${options.title}</title>
  <style>
:root {
${tokenCSS}
}
${criticalCSS}
  </style>
</head>
<body>
  ${bodyHTML}
</body>
</html>`;

  // 5. 资源固化
  html = await solidifyAssets(html);

  return html;
}
```

### 输出产物特点

| 特点 | 说明 |
|------|------|
| **单文件** | 一个 `.html` 文件包含一切，无外部依赖 |
| **零配置运行** | 双击即可在浏览器打开，无需服务器 |
| **离线可用** | 所有资源内联，断网也能正常显示 |
| **加载极快** | CSS 仅几 KB，首屏秒开 |
| **可嵌入** | 可以直接嵌入邮件、PPT、文档 |

### 与组件工厂的关系

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  组件工厂 (Component Factory)                                    │
│  ├─ 输入: AST + Design Tokens                                   │
│  ├─ 处理: Props 归一化 + 插槽分发 + 事件桩函数 + Context 注入    │
│  └─ 输出: React 组件树 (活的，有状态)                            │
│       │                                                          │
│       ▼                                                          │
│  SSR 引擎 (Server Side Rendering)                                │
│  ├─ 输入: React 组件树                                          │
│  ├─ 处理: 脱水渲染 + 样式萃取 + 资源固化                         │
│  └─ 输出: 单文件 HTML (静态，可离线)                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 视觉引擎版本规划

### V1：静态别名映射（当前实现）

简单的查表映射，快速可用：

```typescript
import { z } from "zod";

// ============================================
// V1: 静态别名映射
// ============================================

const colorAliases: Record<string, string> = {
  // 蓝色系
  "blue": "blue-600",
  "ocean_blue": "blue-600",
  "sky": "blue-400",
  "navy": "blue-800",
  // 绿色系
  "green": "green-600",
  "teal": "teal-600",
  "medical": "teal-600",
  // 红色系
  "red": "red-600",
  "danger": "red-600",
  "error": "red-600",
};

const ColorAttr = z.string().transform((val) => {
  const key = val.toLowerCase();
  return colorAliases[key] || key;
});

// V1 使用示例
const input = { color: "OCEAN_BLUE" };
const result = ColorAttr.parse(input.color);  // → "blue-600"
```

**V1 特点**：
- ✅ 简单、快速、可预测
- ✅ 易于调试和维护
- ❌ 不够灵活，只有有限的预设组合
- ❌ 不支持场景感知

---

### V2：场景感知 + 可计算设计（目标架构）

设计变得"可计算"，同一语义在不同场景产出不同视觉：

```
┌─────────────────────────────────────────────────────────────────┐
│                      V2 视觉引擎输入                             │
│                                                                  │
│  1. 语义属性: COLOR(BLUE), SIZE(LARGE)                          │
│  2. 场景上下文: CONTEXT("技术调研") / CONTEXT("儿童教育")        │
│  3. Hash 种子: hash(session_id + context)                       │
│                                                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                   场景感知的颜色映射                             │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("技术调研")                       │   │
│  │    场景特征: 深邃、专业、可信                             │   │
│  │    色相区间: [210, 240]                                  │   │
│  │    饱和度: 60-80%                                        │   │
│  │    明度: 25-40%                                          │   │
│  │    → #1E40AF (深邃蓝)                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("儿童教育")                       │   │
│  │    场景特征: 活泼、明亮、友好                             │   │
│  │    色相区间: [200, 220]                                  │   │
│  │    饱和度: 70-90%                                        │   │
│  │    明度: 55-70%                                          │   │
│  │    → #60A5FA (天空蓝)                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  COLOR(BLUE) + CONTEXT("医疗健康")                       │   │
│  │    场景特征: 可信、清洁、专业                             │   │
│  │    色相区间: [180, 200]                                  │   │
│  │    饱和度: 50-70%                                        │   │
│  │    明度: 40-55%                                          │   │
│  │    → #0891B2 (青蓝)                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**V2 核心算法**：

```typescript
// ============================================
// V2: 场景感知 + Hash 确定性
// ============================================

interface ContextConstraints {
  hueRange: [number, number];
  satRange: [number, number];
  lightRange: [number, number];
  radiusScale: number;      // 圆角系数
  spacingScale: number;     // 间距系数
  fontScale: number;        // 字体系数
  shadowIntensity: number;  // 阴影强度
}

// 场景 → 约束范围
const contextConstraints: Record<string, ContextConstraints> = {
  "技术调研": {
    hueRange: [210, 240],
    satRange: [60, 80],
    lightRange: [25, 40],
    radiusScale: 0.5,       // 较小圆角，硬朗
    spacingScale: 1.0,      // 标准间距
    fontScale: 1.0,         // 标准字体
    shadowIntensity: 0.3,   // 轻阴影
  },
  "儿童教育": {
    hueRange: [200, 220],
    satRange: [70, 90],
    lightRange: [55, 70],
    radiusScale: 1.5,       // 大圆角，柔和
    spacingScale: 1.2,      // 宽松间距
    fontScale: 1.1,         // 稍大字体
    shadowIntensity: 0.5,   // 明显阴影
  },
  "医疗健康": {
    hueRange: [180, 200],
    satRange: [50, 70],
    lightRange: [40, 55],
    radiusScale: 0.75,      // 中等圆角
    spacingScale: 1.1,      // 舒适间距
    fontScale: 1.0,         // 标准字体
    shadowIntensity: 0.2,   // 极轻阴影，干净
  },
  "金融商务": {
    hueRange: [220, 250],
    satRange: [40, 60],
    lightRange: [20, 35],
    radiusScale: 0.25,      // 极小圆角，严肃
    spacingScale: 0.9,      // 紧凑间距
    fontScale: 0.95,        // 稍小字体
    shadowIntensity: 0.4,   // 中等阴影
  },
};

// Hash 函数（确定性）
function hashCode(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

// V2 颜色计算
function computeColor(
  semanticColor: string,
  context: string,
  sessionId: string
): string {
  const constraints = contextConstraints[context] || contextConstraints["技术调研"];
  const seed = hashCode(sessionId + context + semanticColor);

  const [hueMin, hueMax] = constraints.hueRange;
  const [satMin, satMax] = constraints.satRange;
  const [lightMin, lightMax] = constraints.lightRange;

  const hue = hueMin + (seed % (hueMax - hueMin));
  const sat = satMin + ((seed >> 8) % (satMax - satMin));
  const light = lightMin + ((seed >> 16) % (lightMax - lightMin));

  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

// V2 完整 Design Tokens 生成
function generateDesignTokens(
  context: string,
  sessionId: string
): Record<string, string> {
  const constraints = contextConstraints[context] || contextConstraints["技术调研"];
  const baseUnit = 8;

  return {
    // 颜色
    "--primary-color": computeColor("PRIMARY", context, sessionId),
    "--secondary-color": computeColor("SECONDARY", context, sessionId),
    "--background": computeColor("BACKGROUND", context, sessionId),
    "--foreground": computeColor("FOREGROUND", context, sessionId),

    // 空间（受场景影响）
    "--base-unit": `${baseUnit}px`,
    "--spacing-sm": `${baseUnit * constraints.spacingScale}px`,
    "--spacing-md": `${baseUnit * 2 * constraints.spacingScale}px`,
    "--spacing-lg": `${baseUnit * 3 * constraints.spacingScale}px`,

    // 圆角（受场景影响）
    "--radius-sm": `${4 * constraints.radiusScale}px`,
    "--radius-md": `${8 * constraints.radiusScale}px`,
    "--radius-lg": `${12 * constraints.radiusScale}px`,

    // 字体（受场景影响）
    "--font-scale": `${constraints.fontScale}`,
    "--font-size-base": `${16 * constraints.fontScale}px`,

    // 阴影（受场景影响）
    "--shadow-sm": `0 1px 2px rgba(0,0,0,${constraints.shadowIntensity * 0.5})`,
    "--shadow-md": `0 4px 6px rgba(0,0,0,${constraints.shadowIntensity})`,
    "--shadow-lg": `0 10px 15px rgba(0,0,0,${constraints.shadowIntensity * 1.5})`,
  };
}

// 使用示例
const tokens = generateDesignTokens("儿童教育", "sess_001");
// {
//   "--primary-color": "hsl(208, 78%, 62%)",  // 天空蓝
//   "--base-unit": "8px",
//   "--spacing-md": "19.2px",                  // 1.2x 宽松
//   "--radius-md": "12px",                     // 1.5x 大圆角
//   "--font-size-base": "17.6px",              // 1.1x 稍大
//   "--shadow-md": "0 4px 6px rgba(0,0,0,0.5)" // 明显阴影
// }
```

**V2 确定性保证**：

```
┌─────────────────────────────────────────────────────────────────┐
│                      Hash 确定性                                 │
│                                                                  │
│  输入相同 → 输出相同                                             │
│                                                                  │
│  第一次生成:                                                     │
│    generateDesignTokens("儿童教育", "sess_001")                  │
│    → "--primary-color": "hsl(208, 78%, 62%)"                    │
│                                                                  │
│  第二次生成（同样输入）:                                         │
│    generateDesignTokens("儿童教育", "sess_001")                  │
│    → "--primary-color": "hsl(208, 78%, 62%)"  ✓ 相同            │
│                                                                  │
│  不同 Session:                                                   │
│    generateDesignTokens("儿童教育", "sess_002")                  │
│    → "--primary-color": "hsl(212, 82%, 65%)"  ✗ 不同            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### V1 → V2 升级路径

```
┌─────────────────────────────────────────────────────────────────┐
│                       升级路径                                   │
│                                                                  │
│  V1 (当前)                      V2 (目标)                       │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  静态别名映射                   场景感知映射                     │
│  colorAliases["blue"]          computeColor("BLUE", context)    │
│       ↓                              ↓                          │
│  "blue-600"                    "hsl(208, 78%, 62%)"             │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  固定 Preset                    可计算设计                       │
│  presets.tech                   generateDesignTokens(context)   │
│  presets.medical                     +                          │
│  presets.edu                    Hash 确定性种子                  │
│  (12种)                         (无限组合)                       │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  渲染器 (Renderer)              编译器 (Compiler)                │
│  JSON → React                   DSL → AST → IR → 多后端         │
│  无状态                         Session State                    │
│  无校验                         幻觉检测 + 语义校验              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 拼写纠错（V1/V2 通用）

如果 AI 输出有拼写错误，用 Levenshtein 距离做模糊匹配：

```typescript
import { distance } from "fastest-levenshtein";

function fuzzyMatch(input: string, candidates: string[]): string | null {
  const threshold = 2;
  for (const candidate of candidates) {
    if (distance(input.toLowerCase(), candidate) <= threshold) {
      return candidate;
    }
  }
  return null;
}

// 使用
fuzzyMatch("BLUEE", ["blue", "red", "green"]);  // → "blue"
```

---

## 存储策略

### 核心原则

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ✅ 持久化：DSL（源代码）                                        │
│  ❌ 不持久化：AST（内存中的编译产物）                            │
│  ❌ 不持久化：Design Tokens（实时计算）                          │
│                                                                  │
│  "以计算代替存储"                                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 数据流与生命周期

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  DSL (持久化 - 文件系统)                                         │
│  screens/home.dsl.json  ←───────────────────┐                   │
│       │                                      │                   │
│       ▼ 编译 (每次打开/修改时)               │ 保存修改          │
│                                              │                   │
│  AST (内存 - 不持久化)                       │                   │
│  只在编译器进程内存中存在                    │                   │
│       │                                      │                   │
│       │                                      │                   │
│       ├──────────────────────────────────────┤                   │
│       │                                      │                   │
│       ▼                                      │                   │
│  Design Tokens (内存 - 实时计算)             │                   │
│  hash(context + session_id) → CSS 变量       │                   │
│       │                                      │                   │
│       ▼                                      │                   │
│  渲染输出 (React/HTML)                       │                   │
│       │                                      │                   │
│       │  用户修改                            │                   │
│       └──────────────────────────────────────┘                   │
│          修改回写到 DSL，重新编译                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 为什么 AST 不持久化

| 方案 | 优点 | 缺点 |
|------|------|------|
| ❌ DSL + AST 都存 | 修改时可直接操作 AST | 需要保持两者同步，容易不一致 |
| ✅ 只存 DSL | 单一数据源，无同步问题 | 每次修改要先编译（但编译很快） |

**选择只存 DSL 的原因**：
1. **单一数据源**：DSL 是唯一的 truth，不会出现 AST 和 DSL 不一致的问题
2. **编译成本低**：Chevrotain + Zod 解析一个页面是毫秒级的
3. **修改更安全**：所有修改都回到 DSL 层面，经过完整的编译校验流程

### 为什么 Design Tokens 不持久化

设计是迭代的。用户今天觉得蓝色好，明天可能想试试绿色。

**实时计算的好处**：
- 用户改 context，Tokens 自动变
- 用户改参数，Tokens 自动变
- 只要输入一样，输出就一样（Hash 确定性）
- 导出时才固化，之前随便调

**"以计算代替存储"**：
- 不存整张 Token 表
- 只存 context 字符串
- 视觉引擎每次运行 `hash(context)` 都能得到一模一样的 Token 表
- 既节省空间又保证绝对一致性

### 什么要存，什么不存

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  ✅ 要持久化：DSL 源文件                                         │
│                                                                  │
│     DSL 是用户意图的"源代码"。                                   │
│     用户要改文字、改布局，都是在 DSL 层面修改，                   │
│     改完重新编译。                                               │
│                                                                  │
│     存储位置：                                                   │
│     project/screens/                                             │
│     ├── home.dsl.json                                           │
│     ├── user-list.dsl.json                                      │
│     └── ...                                                      │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ✅ 要持久化：Context 配置                                       │
│                                                                  │
│     存储位置：                                                   │
│     - 项目配置文件: stitch.config.json (context, session_id)    │
│     - 会话缓存: 在规划层 AI 的对话历史里                         │
│                                                                  │
│     Context 是连接用户和 AI 的纽带，也是 Design Tokens 的种子    │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ❌ 不持久化：AST                                                │
│                                                                  │
│     AST 只在内存中存在。                                         │
│     打开页面时：DSL → 编译 → AST（内存）                         │
│     修改页面时：修改 DSL → 重新编译 → 新 AST（内存）             │
│                                                                  │
│     不直接操作 AST，所有修改都回到 DSL 层面。                    │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ❌ 不持久化：Design Tokens                                      │
│                                                                  │
│     渲染时：根据 context + session_id 实时计算                   │
│     只在导出时才固化成 CSS 文件                                  │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ✅ 导出时才生成：最终产物                                       │
│                                                                  │
│     用户点击"导出"的那一刻：                                     │
│     1. 根据当前 context + session_id 计算 Design Tokens          │
│     2. 编译所有 DSL → AST → IR → 目标代码                       │
│     3. 把 Tokens 写入 design-tokens.css（此时才固化）            │
│     4. 打包输出                                                  │
│                                                                  │
│     输出位置：                                                   │
│     dist/                                                        │
│     ├── design-tokens.css   ← 导出时生成                        │
│     ├── index.html                                               │
│     └── ...                                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 完整工作流程

#### 打开页面

```
用户打开 home 页面
       │
       ▼
读取 DSL: screens/home.dsl.json
       │
       ▼
编译: DSL → AST (进入内存)
       │
       ▼
读取 context: stitch.config.json
       │
       ▼
计算 Design Tokens: hash(context + session_id)
       │
       ▼
渲染: AST + Tokens → React 组件树
       │
       ▼
显示预览
```

#### 修改页面

用户要改按钮文字"提交"→"确认"：

```
用户点击按钮，输入新文字"确认"
       │
       ▼
定位 DSL 中对应节点
       │
       ▼
修改 DSL: [Content - Header] ... "确认"按钮
       │
       ▼
保存 DSL 文件: screens/home.dsl.json
       │
       ▼
重新编译: DSL → 新 AST (内存中替换)
       │
       ▼
Design Tokens 不变 (context 没变)
       │
       ▼
重新渲染预览
```

**注意**：不直接操作内存中的 AST，修改都回到 DSL 层面，经过完整编译流程。

#### 导出项目

```
用户点击"导出"
       │
       ▼
读取 stitch.config.json (context, session_id)
       │
       ▼
计算 Design Tokens (此时固化值)
       │
       ▼
遍历 screens/*.dsl.json
       │
       ├─→ 编译 home.dsl.json → home.html
       ├─→ 编译 user-list.dsl.json → user-list.html
       └─→ ...
       │
       ▼
写入 dist/design-tokens.css (固化的 CSS 变量)
       │
       ▼
打包输出 dist/
```

---

## 云端存储架构

### 为什么用文件系统而不是数据库

Stitch 是云端版本，但 DSL 存在服务器文件系统，不用数据库。原因：

**简单可靠**
- 不需要维护数据库
- 文件系统天然支持目录隔离
- 每个用户/项目一个目录，互不干扰

**可以用 Git 版本控制**
- 服务器上可以给每个项目初始化 Git 仓库
- 自动记录修改历史
- 用户可以回滚到任意版本

**容易备份和迁移**
- 直接打包目录就能备份
- 可以用对象存储（S3、OSS）做异地同步
- 迁移服务器只需要复制文件夹

**符合编译器的工作方式**
- 编译器读写文件是最自然的
- 不需要序列化/反序列化到数据库
- 文件路径就是资源定位符

### 服务器目录结构

```
/data/stitch/
│
├── users/
│   └── {user_id}/
│       └── projects/
│           │
│           ├── {project_id}/                    # 项目 A
│           │   ├── stitch.config.json           # 项目配置
│           │   │   {
│           │   │     "name": "医疗健康App",
│           │   │     "context": "医疗健康，专业可信",
│           │   │     "sessionId": "sess_001",
│           │   │     "createdAt": "2024-01-15",
│           │   │     "platform": "web"
│           │   │   }
│           │   │
│           │   ├── screens/                     # DSL 源文件
│           │   │   ├── home.dsl.json           # 首页
│           │   │   ├── user-list.dsl.json      # 用户列表
│           │   │   ├── user-detail.dsl.json    # 用户详情
│           │   │   └── settings.dsl.json       # 设置页
│           │   │
│           │   ├── assets/                      # 静态资源
│           │   │   ├── logo.svg
│           │   │   └── ...
│           │   │
│           │   ├── .git/                        # Git 版本控制（可选）
│           │   │
│           │   └── dist/                        # 编译输出
│           │       ├── design-tokens.css
│           │       ├── index.html
│           │       └── ...
│           │
│           └── {project_id}/                    # 项目 B
│               └── ...
│
└── tmp/                                         # 临时文件（编译中间产物）
    └── ...
```

### 文件说明

| 文件/目录 | 作用 | 持久化 |
|----------|------|--------|
| `stitch.config.json` | 项目配置（context、session_id） | ✅ |
| `screens/*.dsl.json` | DSL 源文件，用户意图的源代码 | ✅ |
| `assets/` | 用户上传的图片、图标等 | ✅ |
| `.git/` | 版本历史（可选） | ✅ |
| `dist/` | 编译输出，导出时生成 | 可选（可重新生成） |
| `tmp/` | 编译临时文件 | ❌ 用完即删 |

### 读写流程

**用户打开项目**：
1. 根据 user_id 和 project_id 定位目录
2. 读取 `stitch.config.json` 获取配置
3. 列出 `screens/` 目录下所有 DSL 文件
4. 根据 context 实时计算 Design Tokens
5. 编译 DSL → 渲染预览

**用户修改页面**：
1. 修改内存中的 DSL 结构
2. 保存到 `screens/xxx.dsl.json`
3. 重新编译该页面
4. 更新预览

**用户导出项目**：
1. 读取当前配置，计算 Design Tokens
2. 编译所有 DSL 文件
3. 生成 `dist/` 目录下的文件
4. 打包下载或部署

---

## DSL 解析与 AST 构建

### 编译器处理流程

```
┌─────────────────────────────────────────────────────────────────┐
│  规划层 AI 输出的 JSON                                           │
│  {                                                               │
│    "title": "OpenCode 流程图",                                   │
│    "context": "技术架构",                                        │
│    "description": "[SECTION: Execution_Flow]\n  { Gutter:..."   │
│  }                                                               │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 1: Chevrotain 词法分析 (Lexer)                             │
│                                                                  │
│  输入 DSL：                                                      │
│  [SECTION: Execution_Flow]                                       │
│    { Gutter: "32px", Align: "Center" }                          │
│    [CARD: node_opencode]                                         │
│      ATTR: Title("OpenCode 接口调用"), Icon("Terminal")          │
│                                                                  │
│  输出 Token 流：                                                 │
│  [SECTION_TAG, COLON, ID("Execution_Flow"), NEWLINE,            │
│   LBRACE, KEY("Gutter"), COLON, STRING("32px"), ...,            │
│   CARD_TAG, COLON, ID("node_opencode"), NEWLINE,                │
│   ATTR, COLON, FUNC("Title"), LPAREN, STRING("..."), ...]       │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 2: Chevrotain 语法分析 (Parser)                            │
│                                                                  │
│  根据缩进和嵌套规则构建 CST：                                    │
│  {                                                               │
│    tag: "SECTION", id: "Execution_Flow",                        │
│    layoutProps: { Gutter: "32px", Align: "Center" },           │
│    children: [{                                                  │
│      tag: "CARD", id: "node_opencode",                          │
│      attrs: [                                                    │
│        { key: "Title", value: "OpenCode 接口调用" },            │
│        { key: "Icon", value: "Terminal" }                       │
│      ],                                                          │
│      children: [...]                                             │
│    }]                                                            │
│  }                                                               │
│                                                                  │
│  💡 ID 自动生成：                                                │
│  如果 DSL 没写 ID，Parser 自动生成 card_1, btn_2 等             │
│  方便后续 edit_design 的 Diff 算法定位节点                       │
└───────────────────────────┬─────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│  Step 3: Zod 语义收敛 (Transform)                                │
│                                                                  │
│  CST → 标准化 AST：                                              │
│  - 属性收敛：Title("xxx") → title: "xxx"                        │
│  - 别名映射：Align("Center") → align: "center"                  │
│  - 默认值补全：Button 无 variant → variant: "primary"           │
│  - 视觉 Token 预注入：根据 context 注入 defaultPrimaryColor 等  │
│                                                                  │
│  输出 AST：                                                      │
│  {                                                               │
│    type: "Root",                                                 │
│    children: [{                                                  │
│      id: "node_section_1",                                      │
│      type: "Section",                                            │
│      props: { gutter: "32px", align: "center" },                │
│      children: [{                                                │
│        id: "node_opencode",                                     │
│        type: "Card",                                             │
│        props: { title: "OpenCode 接口调用", icon: "Terminal" }, │
│        children: [...]                                           │
│      }]                                                          │
│    }]                                                            │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### Step 1: Chevrotain 词法分析器

解析 AI 输出的结构化 DSL：

```typescript
// ============================================
// lexer.ts - 解析 [TAG: id], ATTR:, CONTENT: 等标签
// ============================================

import { createToken, Lexer } from "chevrotain";

// 标签类型
export const SectionTag = createToken({
  name: "SectionTag",
  pattern: /\[SECTION/
});

export const CardTag = createToken({
  name: "CardTag",
  pattern: /\[CARD/
});

export const ButtonTag = createToken({
  name: "ButtonTag",
  pattern: /\[BUTTON/
});

export const EditTag = createToken({
  name: "EditTag",
  pattern: /\[Edit\s*-\s*([^\]]+)\]/
});

export const DetailsTag = createToken({
  name: "DetailsTag",
  pattern: /\[Details\]/
});

export const TextContent = createToken({
  name: "TextContent",
  pattern: /[^\[]+/,
});

export const allTokens = [
  LayoutTag, ThemeTag, ContentTag, EditTag, DetailsTag, TextContent,
];

export const StitchLexer = new Lexer(allTokens);
```

### Step 2: Zod 内容解析

把 CST 中的 ATTR/CONTENT 转成标准化的 AST 节点：

```typescript
// ============================================
// semantic.ts - Zod 语义收敛
// ============================================

import { z } from "zod";

// CST 中的属性节点
interface CSTAttr {
  key: string;   // 如 "Title", "Icon", "Variant"
  value: string; // 如 "OpenCode 接口调用", "Terminal"
}

// CST 节点
interface CSTNode {
  tag: string;
  id?: string;
  layoutProps?: Record<string, string>;
  attrs?: CSTAttr[];
  content?: string;
  children?: CSTNode[];
}

// 属性键名映射（大写 → 小写）
const propKeyMap: Record<string, string> = {
  "Title": "title",
  "Icon": "icon",
  "Variant": "variant",
  "Size": "size",
  "Gutter": "gutter",
  "Align": "align",
};

// 属性值映射（别名 → 标准值）
const propValueMap: Record<string, Record<string, string>> = {
  variant: { "Outline": "outline", "Primary": "primary", "Ghost": "ghost" },
  size: { "Small": "small", "Medium": "md", "Large": "lg" },
  align: { "Center": "center", "Left": "left", "Right": "right" },
};

// 默认值配置
const defaultProps: Record<string, Record<string, string>> = {
  Button: { variant: "primary", size: "md" },
  Card: { variant: "default" },
};

// ID 自动生成计数器（用于 edit_design Diff）
const idCounters: Record<string, number> = {};
function generateId(type: string): string {
  const key = type.toLowerCase();
  idCounters[key] = (idCounters[key] || 0) + 1;
  return `${key}_${idCounters[key]}`;
}

// 视觉 Token 预注入（根据 context 注入默认颜色）
function injectVisualTokenDefaults(
  props: Record<string, any>,
  type: string,
  context?: string
): void {
  // 如果没有指定颜色，根据 context 注入默认主色
  if (!props.color && !props.variant) {
    if (context?.includes("技术") || context?.includes("架构")) {
      props.defaultPrimaryColor = "blue-600";
    } else if (context?.includes("儿童") || context?.includes("教育")) {
      props.defaultPrimaryColor = "orange-400";
    }
  }
}

// CST → AST 转换 Schema
const CSTNodeSchema: z.ZodType<any> = z.lazy(() =>
  z.object({
    tag: z.string(),
    id: z.string().optional(),
    layoutProps: z.record(z.string()).optional(),
    attrs: z.array(z.object({ key: z.string(), value: z.string() })).optional(),
    content: z.string().optional(),
    children: z.array(CSTNodeSchema).optional(),
  }).transform((cst) => {
    // 1. 标签名映射
    const type = cst.tag.charAt(0) + cst.tag.slice(1).toLowerCase(); // CARD → Card

    // 2. 属性收敛
    const props: Record<string, any> = {};

    // 处理 layoutProps
    if (cst.layoutProps) {
      for (const [key, value] of Object.entries(cst.layoutProps)) {
        const normalizedKey = propKeyMap[key] || key.toLowerCase();
        const normalizedValue = propValueMap[normalizedKey]?.[value] || value.toLowerCase();
        props[normalizedKey] = normalizedValue;
      }
    }

    // 处理 ATTR
    if (cst.attrs) {
      for (const { key, value } of cst.attrs) {
        const normalizedKey = propKeyMap[key] || key.toLowerCase();
        const normalizedValue = propValueMap[normalizedKey]?.[value] || value;
        props[normalizedKey] = normalizedValue;
      }
    }

    // 处理 CONTENT
    if (cst.content) {
      props.content = cst.content; // 内容无损保留
    }

    // 3. 默认值补全
    const defaults = defaultProps[type] || {};
    for (const [key, value] of Object.entries(defaults)) {
      if (!(key in props)) {
        props[key] = value;
      }
    }

    // 4. 视觉 Token 预注入（根据 context 注入默认颜色）
    // 注意：context 需要从外部传入，这里简化示例
    injectVisualTokenDefaults(props, type);

    // 5. 递归处理 children
    const children = cst.children?.map(child => CSTNodeSchema.parse(child));

    // 6. 组装 AST 节点
    // 💡 如果 DSL 没写 ID，自动生成（方便 edit_design Diff）
    const nodeId = cst.id || generateId(type);

    return {
      id: nodeId,
      type,
      props,
      ...(children?.length && { children }),
    };
  })
);

// 导出转换函数
export function transformToAST(cst: CSTNode) {
  return {
    type: "Root",
    children: [CSTNodeSchema.parse(cst)],
  };
}
```

### 完整编译流程示例

```typescript
// ============================================
// compiler.ts - 完整编译入口
// ============================================

import { StitchLexer } from "./lexer";
import { StitchParser } from "./parser";
import { transformToAST } from "./semantic";

export interface ASTNode {
  id?: string;
  type: string;
  props: Record<string, any>;
  children?: ASTNode[];
}

export interface StitchAST {
  type: "Root";
  children: ASTNode[];
}

export function compile(input: {
  title: string;
  context: string;
  description: string;
}): StitchAST {
  // 1. 词法分析
  const lexResult = StitchLexer.tokenize(input.description);

  // 2. 语法分析 → CST
  const parser = new StitchParser();
  parser.input = lexResult.tokens;
  const cst = parser.dsl();

  // 3. 语义收敛 → AST
  return transformToAST(cst);
}

// 输入：规划层 AI 的 JSON
const input = {
  title: "OpenCode 流程图",
  context: "技术架构",
  description: `
[SECTION: Execution_Flow]
  { Gutter: "32px", Align: "Center" }
  [CARD: node_opencode]
    ATTR: Title("OpenCode 接口调用"), Icon("Terminal")
    CONTENT: "执行层通过 handle_opencode_call/7 订阅 SSE 事件"
    [BUTTON: "运行调试"]
      ATTR: Variant("Outline"), Size("Small")
`
};

// 编译
const ast = compile(input);

// 输出：结构化 AST
console.log(JSON.stringify(ast, null, 2));
// {
//   "type": "Root",
//   "children": [{
//     "id": "node_section_1",
//     "type": "Section",
//     "props": { "gutter": "32px", "align": "center" },
//     "children": [{
//       "id": "node_opencode",
//       "type": "Card",
//       "props": { "title": "OpenCode 接口调用", "icon": "Terminal" },
//       "children": [
//         { "type": "Text", "props": { "content": "执行层通过 handle_opencode_call/7 订阅 SSE 事件" } },
//         { "id": "node_btn_1", "type": "Button", "props": { "text": "运行调试", "variant": "outline", "size": "small" } }
//       ]
//     }]
//   }]
// }
```

### AST 设计亮点

| 特性 | 说明 |
|------|------|
| **确定性映射** | `type: "Section"` 直接对应 `Registry["Section"]` 查找组件 |
| **内容无损** | 精准文本（如 `handle_opencode_call/7`）原封不动进入 `props.content` |
| **布局与样式解耦** | AST 只定义"这里有一个 Section，它要居中"，不定义具体像素值 |
| **React 友好** | `props` 字段可直接透传给 React 组件 |

### ⚠️ 工程注意事项

#### 1. 循环引用风险（递归处理）

Zod Schema 必须使用 `z.lazy()` 处理递归的 `children` 嵌套：

```typescript
// ✅ 正确：使用 z.lazy() 支持无限嵌套
const CSTNodeSchema: z.ZodType<any> = z.lazy(() =>
  z.object({
    children: z.array(CSTNodeSchema).optional(), // 递归引用自身
  })
);

// ❌ 错误：直接引用会导致 ReferenceError
const CSTNodeSchema = z.object({
  children: z.array(CSTNodeSchema).optional(), // 💥 CSTNodeSchema 未定义
});
```

#### 2. Token 预注入的优先级（The Cascade）

`props-normalizer.ts` 必须实现样式优先级算法：

```
DSL 显式属性 > Context 动态 Token > 组件库默认值
```

```typescript
// 优先级算法示例
function normalizeProps(dslProps, contextTokens, componentDefaults) {
  return {
    ...componentDefaults,  // 3. 最低优先级
    ...contextTokens,      // 2. 中等优先级
    ...dslProps,           // 1. 最高优先级（DSL 显式写的必须覆盖）
  };
}

// 例：DSL 写了 COLOR("RED")，必须覆盖 context 注入的 blue-600
// ATTR: COLOR("RED") → props.color = "red" ✅
// 而不是被 defaultPrimaryColor 覆盖
```

#### 3. ID 稳定性（Deterministic IDs）

简单计数器（`card_1`, `card_2`）在 `edit_design` 插入节点时会导致 ID 漂移：

```
原始：[card_1] [card_2] [card_3]
插入：[card_1] [NEW]   [card_2→card_3] [card_3→card_4] 💥 ID 漂移
```

解决方案：使用**组件路径哈希**生成稳定 ID：

```typescript
// ✅ 稳定 ID：基于路径，插入节点不影响兄弟节点
function generateStableId(path: string[], type: string, index: number): string {
  // root.section_1.card_1 → 即使插入新节点，原有节点 ID 不变
  return [...path, `${type.toLowerCase()}_${index}`].join('.');
}

// 或使用内容哈希（更稳定）
function generateContentHash(node: CSTNode): string {
  const content = JSON.stringify({ type: node.tag, attrs: node.attrs });
  return `${node.tag.toLowerCase()}_${hash(content).slice(0, 8)}`;
}
```

这样即使在中间插入新卡片，原有节点的 ID 保持稳定，React Diff 不会失效。

---

## 技术选型：AST 解析

### 为什么不用 Tree-sitter

Tree-sitter 是为**编程语言**设计的解析器生成器（TypeScript、Python、Go 等），具有以下特点：

- 处理复杂的上下文无关文法
- 支持增量解析
- 需要编写 grammar.js 语法定义
- 运行时依赖 WASM/Native 模块

**Stitch 不需要 Tree-sitter**，因为：

1. 我们的语法很简单：`INTENT`、`ENTITY`、`ATTR`
2. 不是传统编程语言，而是结构化的 DSL
3. Tree-sitter 引入的复杂度和依赖不值得

---

### 推荐方案：Chevrotain

**Chevrotain** 是 TypeScript 生态中最适合 Stitch 的选择：

| 特性 | 说明 |
|------|------|
| TypeScript 原生 | 用 TS 编写，类型支持完美 |
| 无代码生成 | 直接在运行时定义语法，无需构建步骤 |
| 高性能 | 比 PEG.js 快 3-10 倍 |
| 错误恢复 | 内置错误恢复机制，适合容错编译 |
| 零运行时依赖 | 纯 JS，不依赖 WASM 或 Native |

**安装**：
```bash
npm install chevrotain
```

---

### 备选方案对比

| 方案 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **Chevrotain** ⭐ | 结构化 DSL | TS 原生、快、错误恢复好 | 学习曲线稍陡 |
| **Peggy (PEG.js)** | 简单语法 | 语法直观、易上手 | 需代码生成步骤 |
| **Nearley + Moo** | 歧义语法 | 处理歧义能力强 | 两个库配合使用 |
| **手写正则** | 极简场景 | 零依赖 | 难扩展、难维护 |
| **Tree-sitter** | 编程语言 | 增量解析强 | 过度工程、依赖重 |

---

### Chevrotain 实现示例

#### 1. Token 定义 (lexer.ts)

```typescript
import { createToken, Lexer } from "chevrotain";

// 标签 Token
export const LayoutTag = createToken({
  name: "LayoutTag",
  pattern: /\[Layout\]/
});

export const ThemeTag = createToken({
  name: "ThemeTag",
  pattern: /\[Theme\]/
});

export const ContentTag = createToken({
  name: "ContentTag",
  pattern: /\[Content\s*-\s*([^\]]+)\]/
});

export const EditTag = createToken({
  name: "EditTag",
  pattern: /\[Edit\s*-\s*([^\]]+)\]/
});

export const DetailsTag = createToken({
  name: "DetailsTag",
  pattern: /\[Details\]/
});

// 文本内容（直到下一个标签或结束）
export const TextContent = createToken({
  name: "TextContent",
  pattern: /[^\[]+/,
});

// 换行
export const Newline = createToken({
  name: "Newline",
  pattern: /\r?\n/,
  group: Lexer.SKIPPED,
});

// 空白
export const WhiteSpace = createToken({
  name: "WhiteSpace",
  pattern: /[ \t]+/,
  group: Lexer.SKIPPED,
});

// Token 列表（顺序重要，优先匹配具体的）
export const allTokens = [
  WhiteSpace,
  Newline,
  LayoutTag,
  ThemeTag,
  ContentTag,
  EditTag,
  DetailsTag,
  TextContent,
];

export const StitchLexer = new Lexer(allTokens);
```

#### 2. Parser 定义 (parser.ts)

```typescript
import { CstParser } from "chevrotain";
import { allTokens, LayoutTag, ThemeTag, ContentTag, TextContent } from "./lexer";

class StitchParser extends CstParser {
  constructor() {
    super(allTokens, { recoveryEnabled: true });
    this.performSelfAnalysis();
  }

  // 顶层规则：指令列表
  public instructions = this.RULE("instructions", () => {
    this.MANY(() => {
      this.SUBRULE(this.instruction);
    });
  });

  // 单条指令
  private instruction = this.RULE("instruction", () => {
    this.OR([
      { ALT: () => this.SUBRULE(this.layoutInstruction) },
      { ALT: () => this.SUBRULE(this.themeInstruction) },
      { ALT: () => this.SUBRULE(this.contentInstruction) },
    ]);
  });

  // Layout 指令
  private layoutInstruction = this.RULE("layoutInstruction", () => {
    this.CONSUME(LayoutTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });

  // Theme 指令
  private themeInstruction = this.RULE("themeInstruction", () => {
    this.CONSUME(ThemeTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });

  // Content 指令
  private contentInstruction = this.RULE("contentInstruction", () => {
    this.CONSUME(ContentTag);
    this.OPTION(() => this.CONSUME(TextContent));
  });
}

export const parser = new StitchParser();
```

#### 3. AST 转换 (ast.ts)

```typescript
import { parser } from "./parser";
import { StitchLexer } from "./lexer";

export interface InstructionNode {
  type: "layout" | "theme" | "content" | "edit" | "details";
  param?: string;     // Content/Edit 的参数，如 "Header"
  content: string;    // 标签后的文本内容
}

export interface StitchAST {
  instructions: InstructionNode[];
}

export function parse(input: string): StitchAST {
  // 1. 词法分析
  const lexResult = StitchLexer.tokenize(input);

  if (lexResult.errors.length > 0) {
    console.warn("Lexer errors:", lexResult.errors);
  }

  // 2. 语法分析
  parser.input = lexResult.tokens;
  const cst = parser.instructions();

  if (parser.errors.length > 0) {
    console.warn("Parser errors:", parser.errors);
  }

  // 3. CST → AST 转换
  return cstToAst(cst);
}

function cstToAst(cst: any): StitchAST {
  // CST visitor 实现...
  // 将 Chevrotain 的 CST 转换为我们的 AST 结构
}
```

#### 4. 使用示例

```typescript
import { parse } from "./compiler/frontend/ast";

const input = `
[Layout] Dashboard 布局，顶部统计卡片，下方数据表格
[Theme] 企业蓝，专业简洁
[Content - Header] 标题"用户管理"，右侧"新增用户"按钮
[Content - Stats] 四个统计卡片：总用户数、活跃用户、新增用户、付费用户
[Content - Table] 用户列表表格，列：头像、姓名、邮箱、状态、操作
`;

const ast = parse(input);
// {
//   instructions: [
//     { type: "layout", content: "Dashboard 布局，顶部统计卡片，下方数据表格" },
//     { type: "theme", content: "企业蓝，专业简洁" },
//     { type: "content", param: "Header", content: "标题"用户管理"..." },
//     { type: "content", param: "Stats", content: "四个统计卡片..." },
//     { type: "content", param: "Table", content: "用户列表表格..." },
//   ]
// }
```

---

### 语法扩展性

Chevrotain 的优势在于语法定义是**运行时代码**，扩展非常方便：

```typescript
// 添加新标签只需：
// 1. 定义新 Token
export const InteractionTag = createToken({
  name: "InteractionTag",
  pattern: /\[Interaction\]/
});

// 2. 加入 Token 列表
allTokens.push(InteractionTag);

// 3. 添加 Parser 规则
private interactionInstruction = this.RULE("interactionInstruction", () => {
  this.CONSUME(InteractionTag);
  this.OPTION(() => this.CONSUME(TextContent));
});
```

无需重新生成代码，无需额外构建步骤。

---

## 下一步

1. **安装 Chevrotain**：`npm install chevrotain`
2. **实现词法分析器**：解析 `[Layout]` `[Content]` 等标签
3. **实现设计系统合成器**：Hash 种子 + Session State
4. **实现组件工厂**：Props 归一化 + 插槽分发 + 事件桩函数
5. **实现 SSR 引擎**：脱水渲染 + 样式萃取 + 资源固化
6. **重构现有渲染器**：作为 React 后端集成到编译器中
